[
  {
    "objectID": "2_agro_ecological.html",
    "href": "2_agro_ecological.html",
    "title": "France agro-ecological",
    "section": "",
    "text": "Code\nknitr::opts_chunk$set(message=F, warning=F, results=F, France_excretions_current_4km2fig.align = \"center\",  dev='png')\n\n# Load the function file common to all pages\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\nlibrary(arrow) #to read and write parquet file, and set objects to arrow tables\nlibrary(sf)\nlibrary(cowplot)\nlibrary(patchwork)\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS_RGF93_Lambert93 &lt;- 2154 # number of coordinate projection system used for France (Réseau Géodésique Français 1993 - Lambert 93)\npercent_N_excreted_urine &lt;- 0.85\nN_excretions_agro_ecological_diet &lt;- 3.5 #kgN/cap/year\nN_ferti_non_legumes_agro_ecological_rotation &lt;- 50 #kgN/ha"
  },
  {
    "objectID": "2_agro_ecological.html#excretions",
    "href": "2_agro_ecological.html#excretions",
    "title": "France agro-ecological",
    "section": "excretions",
    "text": "excretions\n\n\nCode\nbreaks &lt;- c(0, 1, 3, 5, 10, 100000)\nlabels &lt;- c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt; 10\")\n\nFrance_excretions_agro_ecological &lt;- f_categorize_densities(\n  France_excretions_agro_ecological, \"tN_excretions_per_km2\", breaks, labels)\n\n\n\n\nCode\nf_grap_map_raster(\n  France_excretions_agro_ecological, \n  category, \"tons of\\nN excreted\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"N excretions in France (~ 280 ktN)\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n#plot at commune scale\n#f_graph_communes(\"N excretions in France(~ 280 ktN)\", \"mean\\nkgN excreted\\nper ha\")"
  },
  {
    "objectID": "2_agro_ecological.html#fertilization",
    "href": "2_agro_ecological.html#fertilization",
    "title": "France agro-ecological",
    "section": "fertilization",
    "text": "fertilization\nagro ecological\ndonne 33.50 kgN/ha dans le sud 31.25 dans le nord\n70 sur permanent crops\n\n\nCode\n#selects columns for interest for year 2019\ndata_map &lt;- France_fertilization_agro_ecological %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) %&gt;%\n  mutate(    \n    kgPmin = 0,\n    kgKmin = 0,\n    kgNorg = 0\n    )\n\n#sf for geographical\ndata_map &lt;- st_as_sf(data_map, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS_RGF93_Lambert93) \n\n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  data_map, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_france\n  )\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\",  c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\ngg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"tons of N\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Agro-ecological demand for N excretions in France (~ 680 ktN)\"\n    )\ngg\n\n\n\n\n\n\n\n\n\nCode\n#save map for manuscript\ngg &lt;- gg + labs(caption=element_blank(), title = element_blank())\nf_save_graph_pdf_png(\n  gg, \"graph/france_fertilization/\", \"map_Nferti_demand_agroeco\",\n  1000, 5, 6\n)\n\n\n\n\nCode\n#remove all elements from environment\nrm(list = ls())"
  },
  {
    "objectID": "1_gather_regions.html",
    "href": "1_gather_regions.html",
    "title": "Untitled",
    "section": "",
    "text": "Code\n# Load the function file\nsource(\"functions.R\")\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\nlibrary(arrow)\n\n\n\nAttaching package: 'arrow'\n\nThe following object is masked from 'package:lubridate':\n\n    duration\n\nThe following object is masked from 'package:utils':\n\n    timestamp\n\n\nCode\nlibrary(data.table)\n\n\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n\n\nCode\nselect_columns &lt;- c(\n  \"Year\", \n  \"our_label\",\n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \"code_old_region_parcel\", \"name_old_region_parcel\",\n  \"code_region_parcel\", \"name_region_parcel\",\n  \"parcel_area_ha\",\n  \"lat_RGF93_LAMB_93_parcel\", \"lon_RGF93_LAMB_93_parcel\",\n  \"CODE_CULTURE\"\n  )\n\n\nThis document is not rendered in the file, it only gathers the regional full results into a France parquet file, which can be quite long.\nLoad half of the regions\n\n\nCode\n# names of the files to be selected\nfile_names_1 &lt;- c(\n  \"R11_Ile_de_France_2015_2020.parquet\",\n  \"R24_Centre_Val_de_Loire_2015_2020.parquet\",\n  \"R27_Bourgogne_Franche_Comte_2015_2020.parquet\",\n  \"R28_Normandie_2015_2020.parquet\",\n  \"R32_Hauts_de_France_2015_2020.parquet\",\n  \"R44_Grand_Est_2015_2020.parquet\"\n)\nfile_names_2 &lt;- c(\n  \"R52_Pays_de_la_Loire_2015_2020.parquet\",\n  \"R53_Bretagne_2015_2020.parquet\",\n  \"R75_Nouvelle_Aquitaine_2015_2020.parquet\",\n  \"R76_Occitanie_2015_2020.parquet\",\n  \"R84_Auvergne_Rhone_Alpes_2015_2020.parquet\",\n  \"R93_Provence_Alpes_Cote_Azur_2015_2020.parquet\",\n  \"R94_Corse_2015_2020.parquet\"\n)\n\n# creating full path from path and file names\nfull_paths &lt;- file.path(\"output/full_data/regional\", file_names_1)\n\n# load the files and gather them\nfrance &lt;- rbindlist(lapply(full_paths, function(file_path) {\n  as.data.table(read_parquet(file_path, col_select = all_of(select_columns)))\n}))\n\n# creating full path from path and file names\nfull_paths &lt;- file.path(\"output/full_data/regional\", file_names_2)\n\nfrance_2 &lt;- rbindlist(lapply(full_paths, function(file_path) {\n  as.data.table(read_parquet(file_path, col_select = all_of(select_columns)))\n}))\n\n\nGather and save the full france data\n\n\nCode\n#gather the 2 halves\nfrance &lt;- rbindlist(list(france, france_2))\nrm(france_2) #remove second half to save memory\n\n\n\n\n#save 1 national file for each year from 2015 to 2020\nfor (i in 2015:2020) {\n  temp &lt;- france[Year == i]\n  \n  f_save_parquet_files(\n    temp,\n    \"output/full_data/\",\n    paste0(\"France_\", i, \".parquet\")\n  )\n}\nrm(temp)\n\n\n\n\nCode\n#to save all CODE_CULTURE x name_old_region_parcel combination concerning N, P and K fertilization\n\n# function to extract fertilization per ha for each (CODE_CULTURE, name_old_region_parcel) combination\nf_ferti_values &lt;- function(dataset, variable_ferti_tot, variable_name_ferti_per_ha){\n  \n  ferti_values &lt;- dataset %&gt;% \n  \n    # compute mean fertilization per ha \n    mutate(\n      !!variable_name_ferti_per_ha := round({{ variable_ferti_tot }}/parcel_area_ha)\n      ) %&gt;%\n    \n    # select only columns of interest\n    group_by(CODE_CULTURE, name_old_region_parcel, !!sym(variable_name_ferti_per_ha)) %&gt;% \n    \n    # remove duplicates, count unique occurrences of combinations (CODE_CULTURE, name_old_region_parcel, fertilization per ha)\n    summarise(count = n(), .groups = 'drop')\n  \n    #remove NaN and NA fertilization values\n    ferti_values &lt;- na.omit(ferti_values)\n    \n  # We want only 1 fertilization value by (CODE_CULTURE, name_old_region_parcel) combination\n  # the multiple values are due to the approximations in the rounding above\n  # So for each combination, we keep only the row with the most common value (highest count) \n  ferti_values &lt;- ferti_values %&gt;% \n    \n    # group by combinations (CODE_CULTURE, name_old_region_parcel)\n    group_by(\n      CODE_CULTURE, name_old_region_parcel\n      ) %&gt;%\n    \n    #for each combination, keep only the row with the highest count\n    slice_max(order_by = count, n = 1, with_ties = FALSE) %&gt;%\n    \n    #drop the \"count\" column\n    select(-count)\n  \n  return(ferti_values)\n  \n}\n\n# extract values for Nmin, Pmin, Kmin, Norg fertilization\nferti_N_min &lt;- f_ferti_values(france, `N mineral fertilization (kgN)`, \"N mineral fertilization (kgN/ha)\")\nferti_P_min &lt;- f_ferti_values(france, `P mineral fertilization (kgP)`, \"P mineral fertilization (kgP/ha)\")\nferti_K_min &lt;- f_ferti_values(france, `K mineral fertilization (kgK)`, \"K mineral fertilization (kgK/ha)\")\nferti_N_org &lt;- f_ferti_values(france, `N organic fertilization (kgN)`, \"N organic fertilization (kgN/ha)\")\n\n# combine all nutriments in 1 dataset\nferti_values &lt;- ferti_N_min %&gt;% \n  full_join(ferti_P_min, by = c(\"CODE_CULTURE\", \"name_old_region_parcel\")) %&gt;%\n  full_join(ferti_K_min, by = c(\"CODE_CULTURE\", \"name_old_region_parcel\")) %&gt;%\n  full_join(ferti_N_org, by = c(\"CODE_CULTURE\", \"name_old_region_parcel\")) \n\n# save full dataset\nf_save_csv_files(ferti_values, \"output/fertilization\", \"fertilization_all_crops.csv\")\n\n\n\n\nCode\n#save graph regional orchards fertilization for manuscript\n#summarize fertilization values by region\ntemp &lt;- france %&gt;%\n  filter(our_label== \"Orchards\") %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  na.omit() %&gt;%\n  summarise(\n    `N mineral fertilization (kgN/ha)` = mean(`N mineral fertilization (kgN)`/parcel_area_ha, na.rm=T),\n    `P mineral fertilization (kgP/ha)` = mean(`P mineral fertilization (kgP)`/parcel_area_ha, na.rm=T),\n    `K mineral fertilization (kgK/ha)` = mean(`K mineral fertilization (kgK)`/parcel_area_ha, na.rm=T),\n    `N organic fertilization (kgN/ha)` = mean(`N organic fertilization (kgN)`/parcel_area_ha, na.rm=T)\n  )\n\n#keep only N ferti\ntemp &lt;- temp %&gt;%\n  select(name_region_parcel, mineral = `N mineral fertilization (kgN/ha)`, organic = `N organic fertilization (kgN/ha)`) %&gt;%\n  mutate(total = mineral + organic) %&gt;%\n  gather(type, value, mineral, organic)\n\ntemp$type &lt;- factor(temp$type,  levels = c(\"organic\", \"mineral\"))\n  \ngg &lt;- ggplot(temp) +\n  geom_col(\n    aes(reorder(name_region_parcel, total), value, fill=type),\n    alpha=.7\n    ) +\n  geom_text(\n    aes(name_region_parcel, total, label=round(total)),\n    hjust=0\n    ) +\n  coord_flip() +\n  theme(\n    panel.grid.major.x = element_line(),\n    panel.grid.minor.x = element_line(),\n    panel.grid.major.y = element_blank()\n    ) +\n  scale_y_continuous(\n    limits = c(0, 200),\n    breaks = seq(0, 200, 20),\n    minor_breaks = seq(0, 200, 10)\n    ) +\n  labs(x=\"\", y=\"kgN/ha\", fill=\"fertilization\")\n\nf_save_graph_pdf_png(\n  gg, \"graph/fertilization_values/\", \"orchards_fertilization_regional\",\n  350, 3, 6\n)\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfor 'Provence-Alpes-Côte d’Azur' in 'mbcsToSbcs': ' substituted for ’ (U+2019)\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R93_Provence_Alpes_Cote_Azur.html",
    "href": "1_R93_Provence_Alpes_Cote_Azur.html",
    "title": "Provences-Alpes_Côte d’Azur",
    "section": "",
    "text": "Code\nregion &lt;- \"Provence-Alpes-Côte d’Azur\"\npath_region &lt;- \"Provence_Alpes_Cote_Azur\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Provence-Alpes-Côte d’Azur region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R76_Occitanie.html",
    "href": "1_R76_Occitanie.html",
    "title": "Occitanie",
    "section": "",
    "text": "Code\nregion &lt;- \"Occitanie\"\npath_region &lt;- \"Occitanie\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Occitanie region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R53_Bretagne.html",
    "href": "1_R53_Bretagne.html",
    "title": "Bretagne",
    "section": "",
    "text": "Code\nregion &lt;- \"Bretagne\"\npath_region &lt;- \"Bretagne\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Bretagne region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R44_Grand_Est.html",
    "href": "1_R44_Grand_Est.html",
    "title": "Grand Est",
    "section": "",
    "text": "Code\nregion &lt;- \"Grand Est\"\npath_region &lt;- \"Grand_Est\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Grand Est region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R28_Normandy.html",
    "href": "1_R28_Normandy.html",
    "title": "Normandie",
    "section": "",
    "text": "Code\nregion &lt;- \"Normandie\"\npath_region &lt;- \"Normandie\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Normandie region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R24_Centre_Val_de_Loire.html",
    "href": "1_R24_Centre_Val_de_Loire.html",
    "title": "Centre-Vale de Loire",
    "section": "",
    "text": "Code\nregion &lt;- \"Centre-Val de Loire\"\npath_region &lt;- \"Centre_Val_de_Loire\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Centre-Val de Loire region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "0_TOPO_vineyards_orchads.html",
    "href": "0_TOPO_vineyards_orchads.html",
    "title": "TOPO database (for vineyards and orchards)",
    "section": "",
    "text": "The TOPO database reports information on the French territory and its infrastructures. You can download it on the géoportail website here, all documentation is available here and the description on this document.\nWe use this database to complete the agricultural area not reported in the RPG database, namely vineyards and orchards. As the complete database is very large (100s GB), we only kept information related to these 2 items in the dowloaded regional shapefiles, stored in OCCUPATION_DU_SOL -&gt; ZONE_DE_VEGETATION.\nVineyards and Orchards data of the TOPO database are described on p177 of the description document.\n\nOrchards (verger): those with an area &lt; 5000 m2 (0.5 ha) are not systematically reported.\nVineyards (vigne): those with an area &lt; 2000 m2 (0.2 ha) are not systematically reported. Data come from multiple databases: RPG, CVI, orthophotographs…\n\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file common to all pages\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load additional packages\nlibrary(sf) # to handle geographical shapefiles\nlibrary(data.table) # for efficient handling of large data\nlibrary(arrow) # to write and read compressed parquet file\nlibrary(cowplot) #for plot_grid multiple plos\nlibrary(patchwork) #for multiple plots\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS_RGF93_Lambert93 &lt;- 2154 # number of coordinate projection system used for France (Réseau Géodésique Français 1993 - Lambert 93)\n\n\n\nPrepare data\n\npre-processdata preparation\n\n\nEven once we only kept the OCCUPATION_DU_SOL -&gt; ZONE_DE_VEGETATION regional files, the remaining data is heavy (24 GB) and long to read. For faster computing, we already ran the deactivated pre-processing code below, to produce in our source directory a much more compressed (13 MB) and faster to read .parquet file.\nFor full reproducibility, you can activate the code below by un-commenting it, unzip BD_TOPO_data.zip (5-6 GB) in our BD_TOPO_data folder in the source folder, and run the full code.\nThis code below\n\nextracts the vineyards and orchards parcels for each French metropolitan regions\ncomputes each parcel area based on its polygon data\nremoves the polygon data and only keeps its centroid coordinate, to save memory\nbinds all regions together\nsaves the binded data as a pre-processed file\n\nIf you do not do these steps, the script will go straight to the next tab data preparation, where it loads the pre-processed file.\n\n\nCode\n# # List of regions ID\n# regions_numbers &lt;- c(\n#   \"11\", \"24\", \"27\", \"28\", \"32\", \"44\", \"52\", \"53\", \"75\", \"76\", \"84\", \"93\", \"94\"\n# )\n# \n# # Function to process each region: filters only orchards and vineyards data\n# process_region &lt;- function(region) {\n#   # message displaying the processed region\n#   cat(\"Processing region:\", region, \"\\n \\n\")\n# \n#   # Construct the shapefile path\n#   shapefile_path &lt;-\n#     paste0(\n#       \"source/BD_TOPO_data/BD_TOPO_data/BDTOPO_3-3_TOUSTHEMES_SHP_LAMB93_R\",\n#       region,\n#       \"_2023-09-15/BDTOPO/1_DONNEES_LIVRAISON_2023-09-00223/BDT_3-3_SHP_LAMB93_R\",\n#       region, \"-ED2023-09-15/OCCUPATION_DU_SOL/ZONE_DE_VEGETATION.shp\"\n#       )\n# \n#   # Read the shapefile\n#   sf_object &lt;- st_read(\n#     shapefile_path,\n#     #read only data about orchards (verger) and vineyards (vigne)\n#     query = \"select ID, NATURE from ZONE_DE_VEGETATION where NATURE in ('Verger', 'Vigne')\"\n#     )\n# \n#   # Convert to data.table to be faster\n#   setDT(sf_object)\n# \n#   # Compute new columns: area in ha, region code\n#   sf_object[, c(\"parcel_area_ha\", \"code_region_parcel\") := .(\n#     as.numeric(st_area(geometry) / 10000), # agricultural plots area, converted from m2 to ha\n#     as.integer(region) # add region number\n#   )]\n# \n#   # print spaces before next region\n#   cat(\"\\n \\n \\n\")\n# \n#   return(sf_object)\n# }\n# \n# # Use lapply to process each region\n# filtered_sf_list &lt;- lapply(regions_numbers, process_region)\n# \n# # Merge all filtered sf objects into one, remove temporary lists\n# merged_sf_object &lt;- rbindlist(filtered_sf_list)\n# rm(filtered_sf_list, regions_numbers, process_region)\n# \n# # Compute coordinates of each polygon plot\n# merged_sf_object[, centroid_coords := st_centroid(geometry)]\n# \n# # Drop heavy polygon geometry column\n# merged_sf_object &lt;- merged_sf_object[, !\"geometry\", with = FALSE]\n# \n# # removes geometry centroid_coords column and transforms into 2 columns, to store in parquet file\n# # latitude and longitude (in projected Coordinate Reference System: RGF93 v1 / Lambert-93)\n# merged_sf_object$lat_RGF93_LAMB_93_parcel &lt;- st_coordinates(merged_sf_object$centroid)[, \"Y\"]\n# merged_sf_object$lon_RGF93_LAMB_93_parcel &lt;- st_coordinates(merged_sf_object$centroid)[, \"X\"]\n# merged_sf_object &lt;- merged_sf_object[, !\"centroid_coords\", with = FALSE]\n# \n# # saves pre-processed file in parquet format\n# arrow::write_parquet(merged_sf_object, \"source/BD_TOPO_data/preprocessed_TOPO_vineyards_orchards.parquet\")\n# \n# rm(merged_sf_object)\n\n\n\n\nLoad the pre-processed data.\n\n\nCode\n#read pre-processed parquet file\nTOPO_vineyards_orchards &lt;- arrow::read_parquet(\"source/BD_TOPO_data/preprocessed_TOPO_vineyards_orchards.parquet\")\n\n# to sf class for geographical join by intersection, to attribute each plot to an old region\nTOPO_vineyards_orchards &lt;- st_as_sf(TOPO_vineyards_orchards, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS_RGF93_Lambert93)\n\n\nAttribute an old region to each vineyards and orchards plots.\n\n\nCode\n# load old regions geographical data (used to link each plot to region fertilization practices)\nsf_old_regions &lt;- st_read(\n  \"source/maps/old_regions/regions-20140306-5m.shp\", \n  options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n  ) \n\nsf_old_regions &lt;- sf_old_regions %&gt;%\n  #select only columns of interest, rename in English\n  select(\n    code_old_region_parcel = code_insee,\n    name_old_region_parcel = nom\n  ) %&gt;%\n  #load only metropolitan areas, remove overseas territories\n  filter(\n    !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n  ) %&gt;%\n  # transform into our coordinate system (French RGF93-Lambert 93)\n  st_transform(CRS_RGF93_Lambert93) \n\n#add old regions by geographical join\nTOPO_vineyards_orchards &lt;- st_join(TOPO_vineyards_orchards, sf_old_regions, join = st_intersects)\nrm(sf_old_regions)\n\n\nCreate 2 different vineyards and orchards files and add current regions names, based on reported regions code.\n\n\nCode\n# load regions keys ID and names\nregion_names &lt;- read_csv(\"source/regions_data/regions_keys.csv\") %&gt;%\n  select(code_region_parcel = code_region, name_region_parcel = name_region) %&gt;%\n  distinct()\n\n#create vineyards file, adds regions names based on code_region_parcel in TOPO\nvineyards &lt;- TOPO_vineyards_orchards %&gt;%\n  filter(NATURE == \"Vigne\") %&gt;%\n  left_join(region_names, by=\"code_region_parcel\")\n \n#create orchards file, adds regions names based on code_region_parcel in TOPO\norchards &lt;- TOPO_vineyards_orchards %&gt;%\n  filter(NATURE == \"Verger\") %&gt;%\n  left_join(region_names, by=\"code_region_parcel\")\n\n#compute national area of vineyards and orchards (in Mha)\narea_vineyards &lt;- round(sum(vineyards$parcel_area_ha)/10^6, 2)\narea_orchards &lt;- round(sum(orchards$parcel_area_ha)/10^6, 2)\n\n#remove temporary files\nrm(TOPO_vineyards_orchards, region_names)\n\n\n\n\n\n\n\nMaps\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\n#create whole francce polygon from regions polygon union\nsf_france &lt;- st_union(sf_regions)\nrm(sf_regions)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n#breaks of ha per km2 legend\nvec_ha_km2_breaks &lt;- c(0, 1, 10, 30, 1000)\n#labels  of ha per km2 legend\nvec_ha_km2_labels &lt;- c(\"&lt; 1 %\", \"1 - 10 %\", \"10 - 30 %\", \"&gt; 30 %\")\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution &lt;- function(dataset, variable, x_intercept, y_annotation, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      limits=c(0.001, 1000),\n      breaks = c(0.01, 0.1, 1, 10, 100, 1000, 10000),\n      labels = c(0.01, 0.1, 1, 10, 100, 1000, 10000)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=y_annotation, geom=\"text\", label=annotation_label, hjust=1\n    )\n  \n  return(gg)\n}\n\n\n\nVineyardsOrchards\n\n\n\nAgricultural plots densityCheck pixel resolution consistency\n\n\n\n\nCode\n#prepare vineyards file for map pipeline\ntemp &lt;- vineyards %&gt;%\n  mutate(Nmin = 0, Pmin = 0, Kmin = 0, Norg = 0) %&gt;% #must add empty values for function f_categorize_densities \n  select(geometry, parcel_area_ha, Nmin, Pmin, Kmin, Norg) #select only variable of interest for rasterization\n\n#prepare vineyards raster with adequate resolution\nraster_density &lt;- f_prepare_raster(\n  temp, \n  parcel_area_ha, Nmin, Pmin, Kmin, Norg,\n  resolution_meters, sf_france\n  )\n\n#add area categories\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", vec_ha_km2_breaks, vec_ha_km2_labels)\n\n#plot map of vineyards density in France\ngg_vineyards &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied by\\nvineyards\", resolution_meters,\n  sf_france, \"#696969\"\n  ) +\n  labs(title = \"Vineyards in France\")\ngg_vineyards\n\n\n\n\n\n\n\n\n\n\n\nI use a resolution of 10 km2, or 1 000 ha. As I rasterize the data based on the centroids of the agricultural plot, this could be an issue if these plots were larger than 1 000 ha, resulting in pixels reporting agricultural area superior to its own area. Fortunately, virtually all the agricultural plots reported in the TOPO data base are &lt; 1 000 ha (left pane), and there is virtually no pixel reporting an inconsistent value &gt; 100 ha/km2.\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  f_graph_distribution(\n    vineyards, parcel_area_ha, \n    resolution_meters^2/10^4, #1 ha = 10 000 m2\n    8000, \"pixels \\nresolution: \\n10 km2 = \\n1 000 ha \", \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\"),\n  f_graph_distribution(\n    raster_density, ha_per_km2, 100,\n    300, \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\"),\n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAgricultural plots densityCheck pixel resolution consistency\n\n\n\n\nCode\n#prepare vineyards file for map pipeline\ntemp &lt;- orchards %&gt;%\n  mutate(Nmin = 0, Pmin = 0, Kmin = 0, Norg = 0) %&gt;% #must add empty values for function f_categorize_densities \n  select(geometry, parcel_area_ha, Nmin, Pmin, Kmin, Norg) #select only variable of interest for rasterization\n\n#prepare orchards raster with adequate resolution\nraster_density &lt;- f_prepare_raster(\n  temp, \n  parcel_area_ha, Nmin, Pmin, Kmin, Norg,\n  resolution_meters, sf_france\n  )\n\n#add area categories\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", vec_ha_km2_breaks, vec_ha_km2_labels)\n\n#plot map of orchards density in France\ngg_orchards &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied by\\norchards\", resolution_meters,\n  sf_france, \"#696969\"\n  ) +\n  labs(title = \"Orchards in France\")\ngg_orchards\n\n\n\n\n\n\n\n\n\n\n\nI use a resolution of 10 km2, or 1 000 ha. As I rasterize the data based on the centroids of the agricultural plot, this could be an issue if these plots were larger than 1 000 ha, resulting in pixels reporting agricultural area superior to its own area. Fortunately, virtually all the agricultural plots reported in the TOPO data base are &lt; 1 000 ha (left pane), and there is virtually no pixel reporting an inconsistent value &gt; 100 ha/km2.\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  f_graph_distribution(\n    orchards, parcel_area_ha, \n    resolution_meters^2/10^4, #1 ha = 10 000 m2\n    8000, \"pixels \\nresolution: \\n10 km2 = \\n1 000 ha \", \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\"),\n  f_graph_distribution(\n    raster_density, ha_per_km2, 100,\n    600, \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\"),\n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\nCode\n#remove temporary files\nrm(raster_density, sf_france)\n\n\n\n\nCode\n#save maps for manuscript\ngg &lt;- gg_orchards + labs(subtitle = \"orchards\", title = \"\", caption = \"\", fill=\"% area\\noccupied by\\norchards or\\nvineyards\") +\n  gg_vineyards + labs(subtitle = \"vineyards\", title = \"\", caption = \"\", fill=\"% area\\noccupied by\\norchards or\\nvineyards\") + \n  plot_layout(guides = \"collect\") &\n  theme(\n    legend.position = \"bottom\"\n  )\nf_save_graph_pdf_png(\n  gg, \"graph/france_fertilization/\", \"map_area_vineyards_orchards\",\n  1000, 5, 7.5\n)\n\n\n\n\n\n\n\n\n\n\nArea by Region\n\n\nCode\nf_graph_area_regions &lt;- function(dataset, region_types){\n  #summary of vineyards area by region\n  summary &lt;- dataset %&gt;%\n    select({{ region_types }}, parcel_area_ha) %&gt;%\n    group_by({{ region_types }}) %&gt;%\n    summarise(\n      area_kha = sum(parcel_area_ha, na.rm=T)/10^3\n    )\n  \n  #plot\n  gg &lt;- ggplot(summary) +\n    geom_col(aes(reorder({{ region_types }}, area_kha), area_kha)) +\n    geom_label(aes(x={{ region_types }}, y=area_kha, label=round(area_kha, 0))) +\n    labs(x=\"\", y=\"thousands ha\") +\n    theme(\n      axis.text.x = element_text(angle=45, h=1)\n    )\n  \n  return(gg)\n}\n\n\n\nVineyardsOrchards\n\n\nThe TOPO database reports 0.8 Mha of vineyards in France. Below is synthesized the area by region.\n\nCurrent regionsOld regions\n\n\n\n\nCode\nf_graph_area_regions(vineyards, name_region_parcel) + labs(title = \"Vineyards area by region\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_area_regions(vineyards, name_old_region_parcel) + labs(title = \"Vineyards area by (old) region\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe TOPO database reports 0.31 Mha of orchards in France. Below is synthesized the area by region.\n\nCurrent regionsOld regions\n\n\n\n\nCode\nf_graph_area_regions(orchards, name_region_parcel) + labs(title = \"Orchards area by region\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_area_regions(orchards, name_old_region_parcel) + labs(title = \"Orchards area by (old) region\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSave data\nWe prepare the data in a standardized format to be saved\n\n\nCode\n#function to save data in csv format\nf_prepare_data_to_save &lt;- function(dataset, label, fertilization_label){\n  \n  #to save in column format, adds latitude and longitude columns\n  dataset$lat_RGF93_LAMB_93_parcel &lt;- st_coordinates(dataset$geometry)[, \"Y\"]\n  dataset$lon_RGF93_LAMB_93_parcel &lt;- st_coordinates(dataset$geometry)[, \"X\"]\n\n  dataset &lt;- dataset %&gt;%\n    #remove centroïd coordinates column\n    st_drop_geometry() %&gt;%\n    \n    #remove NATURE column which just specifies whether orchards or vineyard\n    select(-NATURE) %&gt;%\n    \n    #change ID name to explicitely say it comes from TOPO database\n    rename(ID_TOPO_parcel = ID) %&gt;%\n    \n    #add English label and fertilization for fertilization key\n    mutate(\n      our_label = label,\n      crop_fertilization_label = fertilization_label\n      )\n  \n  return(dataset)\n}\n\nvineyards &lt;- f_prepare_data_to_save(vineyards, \"Vineyards\", \"Vignes\")\norchards &lt;- f_prepare_data_to_save(orchards, \"Orchards\", \"Vergers\")\n\n# artificially add a code crop in TOPO database coherent with RPG nomenclature\norchards$CODE_CULTURE &lt;- \"VRG\" # added VRG code corresponds to \"Verger\" i.e. orchards\nvineyards$CODE_CULTURE &lt;- \"VRC\" # added VRC code corresponds to \"Vigne\" i.e. vineyards\n\n\nFor vineyards, we add a fertilization value for each plot, based on mean fertilization by old regions. For orchards we cannot do it DECRIRE OU ON VA LE FAIRE\n\n\nCode\n#load vineyards fertilization\nfertilization_vineyards &lt;- read_csv(\"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") \nfertilization_vineyards &lt;- fertilization_vineyards %&gt;%\n  select(\n    crop_fertilization_label, \n    name_old_region_parcel = name_old_region, \n    `N mineral mean fertilization (kgN/ha)`,\n    `P mineral mean fertilization (kgP/ha)`,\n    `K mineral mean fertilization (kgK/ha)`,\n    `N organic mean fertilization (kgN/ha)`\n    )\nsetDT(fertilization_vineyards)\nsetDT(vineyards)\n\n#add the fertilization by ha, based on the old regions in fertilization_vineyards\nvineyards[fertilization_vineyards, \n          c(\"N mineral mean fertilization (kgN/ha)\", \n            \"P mineral mean fertilization (kgP/ha)\", \n            \"K mineral mean fertilization (kgK/ha)\",\n            \"N organic mean fertilization (kgN/ha)\"\n            ) := \n            .(`N mineral mean fertilization (kgN/ha)`, \n              `P mineral mean fertilization (kgP/ha)`, \n              `K mineral mean fertilization (kgK/ha)`,\n              `N organic mean fertilization (kgN/ha)`\n              ),\n          on = c(\"crop_fertilization_label\", \"name_old_region_parcel\")\n          ]\n\n#compute fertilization on each plot\nvineyards[, c(\"N mineral fertilization (kgN)\", \n              \"P mineral fertilization (kgP)\", \n              \"K mineral fertilization (kgK)\",\n              \"N organic fertilization (kgN)\"\n              ) :=\n            .(`N mineral mean fertilization (kgN/ha)` * parcel_area_ha,\n              `P mineral mean fertilization (kgP/ha)` * parcel_area_ha,\n              `K mineral mean fertilization (kgK/ha)` * parcel_area_ha,\n              `N organic mean fertilization (kgN/ha)` * parcel_area_ha\n              )\n          ]\n\n\n\n\nCode\nf_save_parquet_files(\n  vineyards, \n  \"output/fertilization/temporary_data/TOPO_vineyards_orchards_data\", \n  \"vineyards.parquet\"\n)\nf_save_parquet_files(\n  orchards, \n  \"output/fertilization/temporary_data/TOPO_vineyards_orchards_data\", \n  \"orchards_without_fertilization.parquet\"\n)\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "0_cultural_practices_surveys.html",
    "href": "0_cultural_practices_surveys.html",
    "title": "Fertilizations Values",
    "section": "",
    "text": "A FAIRE : STANDARDISER OUTPUT DE CHAQUE FICHIER (NOM DES COLONNES)\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='svg')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load additional required libraries\nlibrary(DT) #for interactive tables\n# Load the required libraries\nlibrary(plotly) #for interactive graphs\n#library(ggridges) #fro geom_ridgeline\nlibrary(ggbeeswarm) #for geom_beeswarm \n#library(data.table) #fast handling of large datasets\nlibrary(viridis) #to set viridis color scales\nlibrary(patchwork) #for multiple charts\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\n# molar mass K : 39, O : 16\nK2O_K_conversion_factor &lt;- (2*39)/(2*39+16)\n# molar mass P : 31, O : 16\nP2O5_P_conversion_factor &lt;- (2*31)/(2*31+5*16)\nThis page shows the fertilization values we use for each crop in our dataset. We use 2 main sources.\nThe first one is the French Practical Crop Surveys, applied to major crops and grassland, and to vineyards.\nThe remaining crops are not covered by these surveys. Instead, we use figures in a French report produced by the consultancy firm AND international for the French Ministry of Agriculture."
  },
  {
    "objectID": "0_cultural_practices_surveys.html#major-crops-temporary-leys-and-grassland-2017",
    "href": "0_cultural_practices_surveys.html#major-crops-temporary-leys-and-grassland-2017",
    "title": "Fertilizations Values",
    "section": "Major crops, temporary leys and grassland (2017)",
    "text": "Major crops, temporary leys and grassland (2017)\nAll the figures in this part are from the 2017 French Practical Crop Survey on major crops, temporary leys and grassland (“Enquêtes pratiques culturales en grandes cultures et prairies”).\n\nPrepare data\nFirst we load and organize the data.\n\n\nCode\n#load file containing survey figures\nsurvey_major_crops &lt;- read_csv(\"source/fertilization/practical_crop_surveys/2017_major_crops_leys_grasslands/fertilization_major_crops_leys_grasslands.csv\")\n\n# remove column describing the source of the figures\nsurvey_major_crops &lt;- survey_major_crops %&gt;%\n  select(-source) \n\n# replace ns (non significative) with NAs and transform character values to numerics\nsurvey_major_crops &lt;- survey_major_crops %&gt;%\n  mutate(value = ifelse(value == \"ns\", NA, value))\nsurvey_major_crops$value &lt;- as.numeric(survey_major_crops$value)\n\n#spread columns related to fertilization practices, only keep items of interest\nsurvey_major_crops &lt;- survey_major_crops%&gt;%\n  spread(variable, value) \n\n#rename French variables in our standardized way\nsurvey_major_crops &lt;- survey_major_crops %&gt;% rename(\n  #yield and area\n  `yield (t/ha)` = `rendement (t/ha)`,\n  `mean field area (ha)` = `superficie moyenne (ha)`,\n  `% organic agriculture` = `% agriculture biologique`,\n  # mean fertilization rates\n  `N mineral mean fertilization (kgN/ha)`=`apport moyen (kgN/ha)`,\n  `P mineral mean fertilization (kgP/ha)`=`apport moyen (kgP2O5/ha)`,\n  `K mineral mean fertilization (kgK/ha)`=`apport moyen (kgK2O/ha)`,\n  `N organic mean fertilization (kgN/ha)`=`apport moyen (kgNorga/ha)`,\n  #percent fields fertilized\n  `% fields fertilized N mineral` = `% parcelles fertilisées N`,\n  `% fields fertilized P mineral` = `% parcelles fertilisées P`,\n  `% fields fertilized K mineral` = `% parcelles fertilisées K`,\n  `% fields fertilized organic` = `% parcelles fertilisées orga`,\n  #fertilization on fertilized fields\n  `N mineral fertilization on fertilized fields (kgN/ha)` = `apport sur parcelles fertilisées (kgN/ha)`,\n  `P mineral fertilization on fertilized fields (kgP/ha)` = `apport sur parcelles fertilisées (kgP2O5/ha)`,\n  `K mineral fertilization on fertilized fields (kgK/ha)` = `apport sur parcelles fertilisées (kgK2O/ha)`,\n  `N organic fertilization on fertilized fields (kgN/ha)` = `apport sur parcelles fertilisées (kgNorga/ha)`\n  )\n\n# We convert P2O5 and K2O to P and K.\nsurvey_major_crops$`P mineral mean fertilization (kgP/ha)` &lt;- round(survey_major_crops$`P mineral mean fertilization (kgP/ha)`*P2O5_P_conversion_factor, 1)\n\nsurvey_major_crops$`P mineral fertilization on fertilized fields (kgP/ha)` &lt;- round(survey_major_crops$`P mineral fertilization on fertilized fields (kgP/ha)`*P2O5_P_conversion_factor, 1)\n\nsurvey_major_crops$`K mineral mean fertilization (kgK/ha)` &lt;- round(survey_major_crops$`K mineral mean fertilization (kgK/ha)`*K2O_K_conversion_factor, 1)\n\nsurvey_major_crops$`K mineral fertilization on fertilized fields (kgK/ha)` &lt;- round(survey_major_crops$`K mineral fertilization on fertilized fields (kgK/ha)`*K2O_K_conversion_factor, 1)\n\n\nThe survey presents 2 types of fertilization figures. First, the mean fertilization (in kg/ha) on all the fields. Second, the mean fertilization only on the fields that are fertilized. This latter is not systematically reported. The link between the 2 quantities is:\n\nmean fertilization on all fields = (% of fields fertilized) x (mean fertilization on fertilized fields)\n\nWe compute the missing values from the relation. The extrapolation is completely coherent (in the graphs below, the point are aligned across the 1:1 line), except for permanent and temporary grassland for N organic fertilization. As our study only focuses on mineral fertilization, this does not impact the results.\n\n\nCode\n#if fertilization on fertilized field not reported, we compute it from the other 2 variables\nsurvey_major_crops &lt;- survey_major_crops %&gt;%\n    mutate(\n      #N\n      `N mineral fertilization on fertilized fields (kgN/ha)` = case_when(\n        is.na(`N mineral fertilization on fertilized fields (kgN/ha)`) ~ \n          round(`N mineral mean fertilization (kgN/ha)`/`% fields fertilized N mineral`*100, 1),\n        T ~ round(`N mineral fertilization on fertilized fields (kgN/ha)`, 1)\n      ),\n      #P\n      `P mineral fertilization on fertilized fields (kgP/ha)` = case_when(\n        is.na(`P mineral fertilization on fertilized fields (kgP/ha)`) ~ \n          round(`P mineral mean fertilization (kgP/ha)`/`% fields fertilized P mineral`*100, 1),\n        T ~ round(`P mineral fertilization on fertilized fields (kgP/ha)`, 1)\n      ),\n      #K\n      `K mineral fertilization on fertilized fields (kgK/ha)` = case_when(\n        is.na(`K mineral fertilization on fertilized fields (kgK/ha)`) ~ \n          round(`K mineral mean fertilization (kgK/ha)`/`% fields fertilized K mineral`*100, 1),\n        T ~ round(`K mineral fertilization on fertilized fields (kgK/ha)`, 1)\n      ),\n      #N orga\n      `N organic fertilization on fertilized fields (kgN/ha)` = case_when(\n        is.na(`N organic fertilization on fertilized fields (kgN/ha)`) ~ \n          round(`N organic mean fertilization (kgN/ha)`/`% fields fertilized organic`*100, 1),\n        T ~ round(`N organic fertilization on fertilized fields (kgN/ha)`, 1)\n      )\n    )\n\n# replace NaN (when divided by 0) with 0s\nis.nan.data.frame &lt;- function(x){\n  do.call(cbind, lapply(x, is.nan))\n}\nsurvey_major_crops[is.nan(survey_major_crops)] &lt;- 0\n\n# replace inf (when divided by 0) with 0s\nis.inf.data.frame &lt;- function(x) {\n  do.call(cbind, lapply(x, is.infinite))\n}\nsurvey_major_crops[is.inf.data.frame(survey_major_crops)] &lt;- 0\n\nrm(is.nan.data.frame, is.inf.data.frame)\n\n\n\n\nCode\n#function to see coherence between reported and computed quantities\nf_graph_coherence_ferti &lt;- function(column_ferti, column_perc_ferti, column_mean_ferti, label_nutrient, label_unit){\n  gg &lt;- ggplot(survey_major_crops) +\n    geom_point(\n      aes(\n        x={{ column_ferti }}*{{ column_perc_ferti }}/100, \n        y={{ column_mean_ferti }},\n        text = paste0(\n          \"region: \", name_old_region, \"\\n\", \n          \"crop: \", crop_fertilization_label\n          )\n        )\n      ) +\n    labs(\n      x=paste0(\"(\", label_nutrient, \" fertilization on fertilized fields) x (% fields fertilized)\", \"\\n (\", label_unit, \")\") ,\n      y=paste0(label_nutrient, \" mean fertilization \", \"\\n (\", label_unit, \")\"),\n      title = paste0(\"coherence of computed and reported quantities, \", label_nutrient)\n    ) \n  \n  return(ggplotly(gg, tooltip = c(\"text\")))\n}\n\n\n\nN orgaN minP minK min\n\n\n\n\nCode\nf_graph_coherence_ferti(\n  `N organic fertilization on fertilized fields (kgN/ha)`,\n  `% fields fertilized organic`,\n  `N organic mean fertilization (kgN/ha)`,\n  \"N organic\", \"kgN/ha\"\n  )\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_coherence_ferti(\n  `N mineral fertilization on fertilized fields (kgN/ha)`,\n  `% fields fertilized N mineral`,\n  `N mineral mean fertilization (kgN/ha)`,\n  \"N mineral\", \"kgN/ha\"\n  )\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_coherence_ferti(\n  `P mineral fertilization on fertilized fields (kgP/ha)`,\n  `% fields fertilized P mineral`,\n  `P mineral mean fertilization (kgP/ha)`,\n  \"P mineral\", \"kgP/ha\"\n  )\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_coherence_ferti(\n  `K mineral fertilization on fertilized fields (kgK/ha)`,\n  `% fields fertilized K mineral`,\n  `K mineral mean fertilization (kgK/ha)`,\n  \"K mineral\", \"kgK/ha\"\n  )\n\n\n\n\n\n\n\n\n\n\n\nVizualize survey data on graphs\nDouble click on an item in the legend to focus on it. Move mouse over graph to see more infos.\n\n\nCode\n #function to make interactive graphs \nf_graph_major_crops_by_crop &lt;- function(data, variable_y, y_max, breaks_legnth, y_label, title_label){\n  unique_regions &lt;- sort(unique(data$name_old_region))\n  colors &lt;- viridis(length(unique_regions))\n  \n  # Create a named vector with region-color mapping\n  region_color_mapping &lt;- setNames(colors, unique_regions)\n  # Change the color for \"France\" to red and add it to the mapping\n  region_color_mapping[\"France\"] &lt;- \"red\"\n\n  gg &lt;- ggplot(data) +\n    geom_beeswarm(\n      aes(\n        reorder(crop_fertilization_label, {{ variable_y }}), {{ variable_y }},\n        color=name_old_region,\n        text = paste(\n          as.character(name_old_region), \"\\n\", \n          as.character(crop_fertilization_label), \"\\n\", \n          as.character(signif({{ variable_y }}, 3)), y_label)\n          )\n      ) +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1)\n    ) +\n    scale_y_continuous(\n      breaks = seq(0, y_max, by = breaks_legnth), \n      limits = c(0, NA)\n      ) +\n    labs(\n      x=\"\", color=\"\", y=y_label, title = title_label\n      ) +\n    scale_color_manual(\n      values = region_color_mapping,\n      breaks = unique_regions,\n      labels = unique_regions\n    ) \n  \n  return(ggplotly(gg, tooltip = c(\"text\")))\n}\n\n\n\nMean Fertilization% FertilizedFertilization on fertilized fieldsYield, Area, % Organic\n\n\nMean fertilization in all fields (includes both fertilized and untertilized fields).\n\nN mineralP mineralK mineralN organic\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `N mineral mean fertilization (kgN/ha)`, 200, 10, \"kgN/ha\", \"Crop mean fertilization by crop type, mineral N\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `P mineral mean fertilization (kgP/ha)`, 40, 5, \"kgP/ha\", \"Crop mean fertilization by crop type, mineral P\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `K mineral mean fertilization (kgK/ha)`, 200, 10, \"kgK/ha\", \"Crop mean fertilization by crop type, mineral K\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `N organic mean fertilization (kgN/ha)`, 200, 10, \"kgN/ha\", \"Crop mean fertilization by crop type, organic N\") \n\n\n\n\n\n\n\n\nCode\nlibrary(RColorBrewer)\npalette &lt;- c(brewer.pal(12, \"Paired\"), brewer.pal(12, \"Set3\"))\n\n#focus on N mineral and organic ferti\ntemp &lt;- survey_major_crops %&gt;%\n  select(name_old_region, crop_fertilization_label, mineral = `N mineral mean fertilization (kgN/ha)`, organic = `N organic mean fertilization (kgN/ha)`) %&gt;%\n  gather(variable, value, c(mineral, organic))\n\n#Reorder by ascending mineral value\ntemp$crop_fertilization_label &lt;- factor(\n  temp$crop_fertilization_label,\n  levels = temp %&gt;% filter(variable == \"mineral\", name_old_region == \"France\") %&gt;% arrange(desc(value)) %&gt;% pull(crop_fertilization_label)\n)\n\ngg &lt;- ggplot(temp) +\n  geom_beeswarm(\n    #region values\n    data = temp %&gt;% filter(name_old_region != \"France\"),\n    aes(\n      crop_fertilization_label, value,\n      color=name_old_region\n      ),\n    alpha=.7\n    ) +\n    #national value in black\n  geom_point(\n    data = temp %&gt;% filter(name_old_region == \"France\"),\n    aes(\n      crop_fertilization_label, value\n      ),\n    fill=\"black\", size=4, shape=18\n  ) +\n  #other graphs options\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  ) +\n  scale_y_continuous(\n    breaks = seq(0, 260, 20)\n  ) +\n  labs(\n    x=\"\", color=\"regions:\", y=\"kgN/ha\", subtitle = \"black diamond: France\"\n    ) +\n  scale_color_manual(\n    values = palette,\n  ) + \n  facet_wrap(vars(variable), ncol=1)\n\nf_save_graph_pdf_png(\n  gg, \"graph/fertilization_values/\", \"major_field_crops_fertilization\",\n  350, 6, 8\n)\n\n\n\n\n\n\n\n% of fields which are actually fertilized.\n\nN mineralP mineralK mineralOrganic fertilizers\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `% fields fertilized N mineral`, 100, 5, \"%\", \"% fields fertilized with mineral N, by crop\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `% fields fertilized P mineral`, 100, 5, \"%\", \"% fields fertilized with mineral P, by crop\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `% fields fertilized K mineral`, 100, 5, \"%\", \"% fields fertilized with mineral K, by crop\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `% fields fertilized organic`, 100, 5, \"%\", \"% fields fertilized with organic fertilizers, by crop\")\n\n\n\n\n\n\n\n\n\n\n\nMean fertilization, excluding fields that are not fertilized.\n\nN mineralP mineralK mineralN organic\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `N mineral fertilization on fertilized fields (kgN/ha)`, 250, 20, \"kgN/ha\", \"Fertilization on fertilized fields, by crop type, mineral N\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `P mineral fertilization on fertilized fields (kgP/ha)`, 60, 5, \"kgP/ha\", \"Fertilization on fertilized fields, by crop, mineral P\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `K mineral fertilization on fertilized fields (kgK/ha)`, 250, 20, \"kgK/ha\", \"Fertilization on fertilized fields, by crop type, mineral K\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `N organic fertilization on fertilized fields (kgN/ha)`, 300, 20, \"kgN/ha\", \"Fertilization on fertilized fields, by crop type, organic N\") \n\n\n\n\n\n\n\n\n\n\n\n\nYieldMean Area% organic fields\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `yield (t/ha)`, 120, 10, \"t/ha\", \"Crops yield by crop type\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `mean field area (ha)`, 100, 5, \"ha\", \"mean field area, by crop type\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_major_crops_by_crop(survey_major_crops, `% organic agriculture`, 100, 5, \"%\", \"% fields in organic agriculture, by crop type\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExplore survey data in a table\nBesides the graphs above, you can also interactively explore the data in the table below.\n\n\nCode\ndatatable(\n  survey_major_crops, options = list(scrollX = TRUE, responsive = TRUE)\n)\n\n\n\n\n\n\n\n\nPermanent grassland regional data\nAs you can see in the graphs above, permanent and temporary grasslands figures are only reported at the national level, and not at the regional level.\nMaybe we will be able to fill this gap later by accessing the original survey data. For now, we can only fill the permanent grassland gap, by using the regional values from Billen et al (2024).\nWe can only add N mineral and P mineral values since K is not assessed in their study. We do not take their N organic values, since they also includes livestock direct excretions on grassland, which is different than the survey looking only at spreading by the farmer. You can check the values in the 2 tabs below.\n\n\nCode\n# load GRAFS data from Billen et al\nGRAFS &lt;- read_csv(\"source/fertilization/GRAFS_Billen_data/GRAFS_ferti_France_regions.csv\")\n\n# get N and P mineral fertilization for permanent grasslands for each regions\nGRAFS &lt;- GRAFS %&gt;% \n  filter(`crop type`==\"permanent grassland\") %&gt;%\n  select(\n    name_old_region, \n    `N mineral mean fertilization (kgN/ha)` = `fertilizer N rate (kgN/ha)`,\n    `P mineral mean fertilization (kgP/ha)`  = `fertilizer P rate (kgP/ha)`\n    ) %&gt;%\n  mutate(crop_fertilization_label = \"13-Prairies Permanentes\")\n\n# add these regional values to fertilization levels file\nsurvey_major_crops &lt;-  bind_rows(survey_major_crops, GRAFS)\n\n\n\nN mineralP mineral\n\n\n\n\nCode\ngg &lt;- ggplot(GRAFS) +\n  geom_col(\n    aes(\n      x = reorder(name_old_region, `N mineral mean fertilization (kgN/ha)`),\n      y = `N mineral mean fertilization (kgN/ha)`,\n      text = paste0(\n        name_old_region, \"\\n\",\n        round(`N mineral mean fertilization (kgN/ha)`), \" kgN/ha\"\n        )\n      )\n    ) +\n  theme(\n    axis.text.x = element_text(angle=45, h=1)\n  ) +\n  labs(x=\"\", title = \"N mineral fertilization on permanent grassland (Billen data)\")\nggplotly(gg, tooltip = c(\"text\"))\n\n\n\n\n\n\n\n\n\n\nCode\ngg &lt;- ggplot(GRAFS) +\n  geom_col(\n    aes(\n      x = reorder(name_old_region, `P mineral mean fertilization (kgP/ha)`),\n      y = `P mineral mean fertilization (kgP/ha)`,\n      text = paste0(\n        name_old_region, \"\\n\",\n        round(`P mineral mean fertilization (kgP/ha)`), \" kgP/ha\"\n        )\n      )\n    ) +\n  theme(\n    axis.text.x = element_text(angle=45, h=1)\n  ) +\n  labs(x=\"\", title = \"P mineral fertilization on permanent grassland (Billen data)\")\nggplotly(gg, tooltip = c(\"text\"))\n\n\n\n\n\n\n\n\nCode\nrm(GRAFS, gg)\n\n\n\n\n\n\n\nExtrapolations for similar crops\nThe survey we use reports practices for some of the major crops (wheat, maize, sugar beet…). However this does not concern all of the major crops grown in France and reported in the RPG dataset. For the ones not surveyed, we assume that the practices is the same as similar surveyed crops. Here is the matching pairs for our extrapolations:\n\n“Other cereals”: approximated with barley values\n“Other oil crops”: approximated with sunflower values\n“Other fiber crops”: approximated with fiber flax values\n“Other protein crops”: approximated with faba bean values\n“Other grain legumes”: approximated with soybean values\n\n\n\nCode\n#new data frame which will hold our extrapolations (so that we keep the survey data frame clean)\nferti_major_crops &lt;- survey_major_crops\n\n#function that adds a crop to the data set (similar_crop) using values of an original crop as proxy\nf_add_similar_crops &lt;- function(orginal_crop_label, similar_crop_label){\n  #create the similar crop data set\n  similar_crop_df &lt;- ferti_major_crops %&gt;%\n    #keep only values of the orginal crop used as a proxy\n    filter(crop_fertilization_label == orginal_crop_label) %&gt;%\n    #replace origina crop name with the new similar crop name\n    mutate(crop_fertilization_label = similar_crop_label)\n  \n  #adds the data to original file\n  ferti_major_crops &lt;- bind_rows(ferti_major_crops, similar_crop_df)\n  \n  return(ferti_major_crops)\n}\n\nferti_major_crops &lt;- f_add_similar_crops(\"03-Orge\", \"Autres céréales\")\nferti_major_crops &lt;- f_add_similar_crops(\"06-Tournesol\", \"Autres oléagineux\")\nferti_major_crops &lt;- f_add_similar_crops(\"17-Lin fibre\", \"Autres plantes à fibres\")\nferti_major_crops &lt;- f_add_similar_crops(\"15-Féverole\", \"Autres protéagineux\")\nferti_major_crops &lt;- f_add_similar_crops(\"16-Soja\", \"Autres légumineuses à graines\")\n\n\nFor fodders:\n\nFodder- Non legume: fodder maize\nFodder- Legume: faba bean\nFodder – Legume + Non Legume: mean of maize and faba bean\n\n\n\nCode\nferti_major_crops &lt;- f_add_similar_crops(\"15-Féverole\", \"Fourrages – Légumineuses\")\nferti_major_crops &lt;- f_add_similar_crops(\"08-Maïs fourrage\", \"Fourrages – Non Légumineuse\")\n\n#fodder legume + non legume : mean of the 2\ntemp_fodder_non_legume &lt;- ferti_major_crops %&gt;% \n  filter(crop_fertilization_label == \"Fourrages – Non Légumineuse\")\ntemp_fodder_legume &lt;- ferti_major_crops %&gt;% \n  filter(crop_fertilization_label == \"Fourrages – Légumineuses\")\n\n#keep only the regions were we have values for both legumes and non legumes fodders\nregions_non_legumes &lt;- unique(temp_fodder_non_legume$name_old_region) #get non legumes regions\nregions_legumes &lt;- unique(temp_fodder_legume$name_old_region) # get legumes regions\ncommon_regions &lt;- unique(intersect(regions_non_legumes, regions_legumes)) #keep only regions in both of them\n\ntemp_fodder_legume_and_non_legume &lt;- \n  bind_rows(temp_fodder_non_legume, temp_fodder_legume) %&gt;% #gather legumes and non legumes proxy\n  filter(name_old_region %in% common_regions) %&gt;% #keep only regions present in both values \n  group_by(name_old_region) %&gt;%\n  summarise_at(vars(-(crop_fertilization_label)) , mean) %&gt;% #take the mean of the 2 values\n  mutate(crop_fertilization_label = \"Fourrages – Légumineuses + Non Légumineuses\")\n\n#add the values to main file\nferti_major_crops &lt;- bind_rows(ferti_major_crops, temp_fodder_legume_and_non_legume)\n\n#remove temporary files\nrm(temp_fodder_non_legume, temp_fodder_legume, temp_fodder_legume_and_non_legume, regions_non_legumes, regions_legumes, common_regions)\n\n\nAlso, for some crops of our RPG data, we just attribute a “0” fertilization value. This is the case for “Fallows” and “Mountain pastures and heaths”, which are obviously not (or almost not) fertilized. We do likewise for the “Others” category, which groups all the rare crops that cannot be grouped in a broad category.\n\n\nCode\n#function to add items with 0 fertilization\nf_add_unfertilized_crops &lt;- function(item_label){\n  #get the first row of the main file and set all values to 0\n  temp &lt;- ferti_major_crops %&gt;% slice(1)\n  temp[,] &lt;- 0\n   \n  #fill the values different than 0\n  temp &lt;- temp %&gt;%\n    mutate(\n      #crop name\n      crop_fertilization_label = item_label,\n      #region: France (other regions will be filled in the next tab \"Extrapolation (region, crop)\")\n      name_old_region = \"France\",\n      #variables not relevant: fill with empty value rather than 0\n      `mean field area (ha)` = NA,\n      `% organic agriculture` = NA\n      ) \n  \n  ferti_major_crops &lt;- bind_rows(ferti_major_crops, temp)\n  \n  return(ferti_major_crops)\n}\n\nferti_major_crops &lt;- f_add_unfertilized_crops(\"Estives et landes\")\nferti_major_crops &lt;- f_add_unfertilized_crops(\"Autres divers\")\nferti_major_crops &lt;- f_add_unfertilized_crops(\"Jachère\")\n\n\n\n\nExtrapolation (region, crop) non surveyed\nNot all crops in all regions are surveyed. You can see the missing regions for each crops in the grid below (red boxes).\n\n\nCode\nf_graph_pairs &lt;- function(dataset){\n  \n  # Surveyed pairs (crops, region)\n  region_crop_surveyed &lt;- dataset %&gt;%\n    select(crop_fertilization_label, name_old_region) %&gt;%\n    distinct()\n\n  # Create all (crop, region) pairs possible\n  all_pairs &lt;- expand.grid(\n    crop = unique(ferti_major_crops$crop_fertilization_label), \n    region = unique(ferti_major_crops$name_old_region)\n    )\n\n  # Add variable indicating if fertilization value surveyed, extrapolated or absent from dataset\n  all_pairs$fertilization &lt;- ifelse(\n    do.call(paste, all_pairs) %in% do.call(paste, region_crop_surveyed),\n    \"Surveyed\",\n    \"Not Surveyed\"\n    )\n\n  # Create a plot\n  gg &lt;- \n    ggplot(\n      all_pairs, \n      aes(\n        x = crop, y = region, fill = fertilization\n        )\n    ) +\n    geom_tile(color = \"white\") +\n    scale_fill_manual(\n      values = c(\"Surveyed\" = \"green\", \"Not Surveyed\" = \"red\")\n      ) +\n    labs(\n      title = \"(region,crop) pairs surveyed\", x = \"\", y = \"\", fill=\"\"\n      ) +\n    theme(\n      axis.text.x = element_text(angle=45, h=1)\n      )\n\n  \n  return(ggplotly(gg))\n}\nf_graph_pairs(ferti_major_crops)\n\n\n\n\n\n\nFor the missing values, we decide to take the French national mean value as an extrapolation.\n\n\nCode\n# Surveyed pairs (crops, region)\nregion_crop_surveyed_2017 &lt;- ferti_major_crops %&gt;%\n  select(crop_fertilization_label, name_old_region) %&gt;%\n  distinct()\n\n# Create all (crop, region) pairs possible\nall_pairs_2017 &lt;- expand.grid(\n  crop_fertilization_label = unique(ferti_major_crops$crop_fertilization_label), \n  name_old_region = unique(ferti_major_crops$name_old_region)\n  )\n\n# Add variable indicating if fertilization value surveyed, extrapolated or absent from dataset\nall_pairs_2017$fertilization &lt;- ifelse(\n  do.call(paste, all_pairs_2017) %in% do.call(paste, region_crop_surveyed_2017),\n  \"Surveyed\",\n  \"Not Surveyed\"\n  )\n\n# creates the main file with all the pairs (for now some empty values)\nferti_major_crops_expanded &lt;- left_join(\n  all_pairs_2017, ferti_major_crops,\n  by=join_by(crop_fertilization_label, name_old_region)\n  )\n\n#get unique region names, crop names and columns names\nregion_names &lt;- unique(ferti_major_crops_expanded$name_old_region)\ncrops_names &lt;- unique(ferti_major_crops_expanded$crop_fertilization_label)\ncolumn_names &lt;- names(ferti_major_crops_expanded %&gt;% select(-crop_fertilization_label, -name_old_region, -fertilization))\n\n#if crop in particular region not surveyed, we take the French mean\nfor (name_old_region in region_names) {\n  for (crop_fertilization_label in crops_names) {\n    for (column in column_names) {\n        if(\n          is.na(ferti_major_crops_expanded[ferti_major_crops_expanded$name_old_region==name_old_region &\n                                           ferti_major_crops_expanded$crop_fertilization_label==crop_fertilization_label, column])\n          ){\n         ferti_major_crops_expanded[\n           ferti_major_crops_expanded$name_old_region==name_old_region &\n             ferti_major_crops_expanded$crop_fertilization_label==crop_fertilization_label, column\n           ] &lt;-\n           ferti_major_crops_expanded[\n             ferti_major_crops_expanded$name_old_region==\"France\" &\n               ferti_major_crops_expanded$crop_fertilization_label==crop_fertilization_label, column]\n        }\n    }\n  }\n}\n#remove temporary variables\nrm(region_names, crops_names, column_names, name_old_region, crop_fertilization_label, column)\n\n#reorder columns\nferti_major_crops &lt;- ferti_major_crops_expanded %&gt;%\n  select(\n    #region and fertilization\n    crop_fertilization_label, name_old_region, \n    #yield, area, % organic\n    `yield (t/ha)`, `mean field area (ha)`, `% organic agriculture`,\n    #mean fertilization\n    `N mineral mean fertilization (kgN/ha)`, `P mineral mean fertilization (kgP/ha)` , `K mineral mean fertilization (kgK/ha)` , `N organic mean fertilization (kgN/ha)`,\n    #%fields fertilized\n    `% fields fertilized N mineral`, `% fields fertilized P mineral`, `% fields fertilized K mineral`, `% fields fertilized organic`,\n    #fertilization on fertilized fields\n    `N mineral fertilization on fertilized fields (kgN/ha)`, `P mineral fertilization on fertilized fields (kgP/ha)`, `K mineral fertilization on fertilized fields (kgK/ha)`, `N organic fertilization on fertilized fields (kgN/ha)`\n  )\n\n\nThe original survey and its extrapolations constitutes our fertilization data for the major crops, that we will add to our main dataset. We save it.\n\n\nCode\n#save our new procesed file\nf_save_csv_files(\n  ferti_major_crops, \n  \"output/fertilization/fertilization_surveys/\",\n  \"fertilization_major_crops_leys_grasslands_by_old_region.csv\")\n\n#remove temporary variables\nrm(all_pairs_2017, region_crop_surveyed_2017, ferti_major_crops_expanded)"
  },
  {
    "objectID": "0_cultural_practices_surveys.html#vineyards-2019",
    "href": "0_cultural_practices_surveys.html#vineyards-2019",
    "title": "Fertilizations Values",
    "section": "Vineyards (2019)",
    "text": "Vineyards (2019)\n\nLoad and Prepare data\nAll the figures in this part are from the 2019 French Practical Crop Survey on vineyards (“Enquêtes pratiques culturales en vitivultue”).\nThey report the results by wine basins, and not by administrative regions. You can see the French wine-growing basins here. We adapt the data to the administrative regions later.\n\n\nCode\npath &lt;- \"source/fertilization/practical_crop_surveys/2019_vineyards/fertilization_wine.csv\"\nsurvey_vineyards &lt;- read_csv(path) \n\n#replace ns with Nas\nsurvey_vineyards &lt;- survey_vineyards %&gt;%\n  mutate(value = ifelse(value == \"ns\", NA, value))\n\n#convert numbers in characters wit \",\" as decimals to numerics\nsurvey_vineyards$value &lt;- as.numeric(gsub(\",\", \".\", survey_vineyards$value))\n\n#spread columns related to fertilization practices, only keep items of interest\nsurvey_vineyards &lt;- survey_vineyards %&gt;%\n  spread(variable, value) \n\n#remove data about organic agriculture\nsurvey_vineyards &lt;- survey_vineyards %&gt;%\n  filter(`organic or all`==\"all\") %&gt;%\n  select(-`organic or all`)\n\n#rename P2O5 and K2O to P and K\nsurvey_vineyards &lt;- survey_vineyards %&gt;% rename(\n  #mineral fertilization on fertilized fields\n  `P mineral fertilization on fertilized fields (kgP/ha)` = `P mineral fertilization on fertilized fields (kgP2O5/ha)`,\n  `K mineral fertilization on fertilized fields (kgK/ha)` = `K mineral fertilization on fertilized fields (kgK2O/ha)`,\n  #organic fertilization on fertilized fields\n  `P organic fertilization on fertilized fields (kgP/ha)` = `P organic fertilization on fertilized fields (kgP2O5/ha)`,\n  `K organic fertilization on fertilized fields (kgK/ha)` = `K organic fertilization on fertilized fields (kgK2O/ha)`\n  )\n\n#convert P205 to P\nsurvey_vineyards$`P mineral fertilization on fertilized fields (kgP/ha)` &lt;- survey_vineyards$`P mineral fertilization on fertilized fields (kgP/ha)`*P2O5_P_conversion_factor\nsurvey_vineyards$`P organic fertilization on fertilized fields (kgP/ha)` &lt;- survey_vineyards$`P organic fertilization on fertilized fields (kgP/ha)`*P2O5_P_conversion_factor\n\n#convert K2O to K\nsurvey_vineyards$`K mineral fertilization on fertilized fields (kgK/ha)` &lt;- survey_vineyards$`K mineral fertilization on fertilized fields (kgK/ha)`*K2O_K_conversion_factor\nsurvey_vineyards$`K organic fertilization on fertilized fields (kgK/ha)` &lt;- survey_vineyards$`K organic fertilization on fertilized fields (kgK/ha)`*K2O_K_conversion_factor\n\n\nThe values reported here are the fertilization values on fields that are effectively fertilized. The survey also reports the % of fields that are fertilized. We compute the mean fertilization value (on all fields, including unfertilized fields) with the following relation:\n\nmean fertilization (on all fields) = (fertilization on fertilized fields) x (% of fertilized fields)\n\n\n\nCode\nsurvey_vineyards &lt;- survey_vineyards %&gt;%\n  mutate(\n    `N mineral mean fertilization (kgN/ha)` = `N mineral fertilization on fertilized fields (kgN/ha)`*`% mineral fertilization`/100,\n    `P mineral mean fertilization (kgP/ha)` = `P mineral fertilization on fertilized fields (kgP/ha)`*`% mineral fertilization`/100,\n    `K mineral mean fertilization (kgK/ha)` = `K mineral fertilization on fertilized fields (kgK/ha)`*`% mineral fertilization`/100,\n    `N organic mean fertilization (kgN/ha)` = `N organic fertilization on fertilized fields (kgN/ha)`*`% organic fertilization`/100,\n    `P organic mean fertilization (kgP/ha)` = `P organic fertilization on fertilized fields (kgP/ha)`*`% organic fertilization`/100,\n    `K organic mean fertilization (kgK/ha)` = `K organic fertilization on fertilized fields (kgK/ha)`*`% organic fertilization`/100\n  )\n\n#round all the values for better display in graphs and interactive table\nsurvey_vineyards &lt;- survey_vineyards %&gt;%\n    mutate_at(vars(-(`wine-growing basin`)) , round)\n\n\n\n\nVizualize survey data on graphs\nYou can see that in the Fertilization tab below, data for some wine basins are missing regarding organic fertilization (Norg, Porg and Korg). This is because because there were too few results and thus it was reported as “non significative”.\nOn the graphs, move mouse over graph to see more infos.\n\n\nCode\nf_graph_vineyard_by_basin &lt;- function(data, variable_y, y_max, breaks_legnth, y_label, title_label){\n\n  gg &lt;- ggplot(data) +\n    geom_col(\n      aes(\n        reorder(`wine-growing basin`, {{ variable_y }}), {{ variable_y }}, \n        text = paste(\n          as.character(`wine-growing basin`), \"\\n\", \n          as.character(signif({{ variable_y }}, 3)), y_label)\n          ),\n      fill = ifelse(\n        #have to filter when missing values, for the scale\n        data %&gt;% filter(is.na({{ variable_y }})==F) %&gt;% pull(`wine-growing basin`) == \"France\", \n        \"red\", \"grey\"\n        )  # Highlight in red if \"France\"\n      ) +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1)\n    ) +\n    scale_y_continuous(\n      breaks = seq(0, y_max, by = breaks_legnth), \n      limits = c(0, NA)\n      ) +\n    labs(\n      x=\"\", color=\"\", y=y_label, title = title_label\n      ) \n  \n  return(ggplotly(gg, tooltip = c(\"text\")))\n}\n\nf_graph_vineyard_by_basin_bis &lt;- function(data, variable_y, y_max, breaks_legnth, y_label, title_label){\n\n  gg &lt;- ggplot(data) +\n    geom_col(\n      aes(\n        reorder(`wine-growing basin`, {{ variable_y }}), {{ variable_y }}),\n        fill = ifelse(# Highlight in red if \"France\"\n          #have to filter when missing values, for the scale\n          data %&gt;% filter(is.na({{ variable_y }})==F) %&gt;% pull(`wine-growing basin`) == \"France\", \n          \"red\", \"grey\"\n          )  \n      ) +\n    geom_text(\n      aes(`wine-growing basin`, {{ variable_y }}, label = {{ variable_y }}),\n      vjust=-0.2, fontface=\"italic\"\n      ) +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1)\n    ) +\n    scale_y_continuous(\n      breaks = seq(0, y_max, by = breaks_legnth), \n      limits = c(0, NA)\n      ) +\n    labs(\n      x=\"\", color=\"\", y=y_label, title = title_label\n      ) \n  \n  return(gg)\n}\n\n\n\nMean Fertilization% Fields FertilizedFertilization on fertilized fieldsArea, Yield, % Organics\n\n\n\nN minN orgP minP orgK minK org\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `N mineral mean fertilization (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"Mean N mineral fertilization\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_basin(survey_vineyards, `N organic mean fertilization (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"Mean N organic fertilization\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `P mineral mean fertilization (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"Mean P mineral fertilization\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_basin(survey_vineyards, `P organic mean fertilization (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"Mean P organic fertilization\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `K mineral mean fertilization (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"Mean K mineral fertilization\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_basin(survey_vineyards, `K organic mean fertilization (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"Mean K organic fertilization\")\n\n\n\n\n\n\n\n\nmineralorganic\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `% mineral fertilization`, 100, 10, \"%\", \"% of fields with mineral fertilization\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `% organic fertilization`, 100, 10, \"%\", \"% of fields with organic fertilization\")\n\n\n\n\n\n\n\n\n\n\n\n\nN minN orgP minP orgK minK org\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `N mineral fertilization on fertilized fields (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"N mineral fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_basin(survey_vineyards, `N organic fertilization on fertilized fields (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"N organic fertilization on fertilized fields\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `P mineral fertilization on fertilized fields (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"P mineral fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_basin(survey_vineyards, `P organic fertilization on fertilized fields (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"P organic fertilization on fertilized fields\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `K mineral fertilization on fertilized fields (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"K mineral fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_basin(survey_vineyards, `K organic fertilization on fertilized fields (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"K organic fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nareayield% organic\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards %&gt;% filter(`wine-growing basin`!=\"France\"), `area (ha)`/10^6, 1, 0.05, \"Mha\", \"vineyard area\") \n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `yield (hl/ha)`, 100, 10, \"hl/ha\", \"Yield by wine-growing basin\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_basin(survey_vineyards, `% fields organic`, 100, 10, \"%\", \"% of fields in organic agriculture\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExplore survey data in a table\nBesides the graphs above, you can also interactively explore the data in the table below.\n\n\nCode\ndatatable(\n  survey_vineyards, options = list(scrollX = TRUE, responsive = TRUE)\n)\n\n\n\n\n\n\n\n\nAdapt data to regions\nThe data from the Vineyards Cultural Practices Survey is detailed by wine basin and not by region. So we adapt the data by matching each region to one or several wine basins.\nYou can see the match beween regions and wine basins in the interactive table below:\n\n\nCode\nkeys_vineyards_basins_regions &lt;- read_csv(\"source/fertilization/practical_crop_surveys/2019_vineyards/keys_vineyard_basin_region.csv\")\n\ndatatable(\n  keys_vineyards_basins_regions, options = list(scrollX = TRUE, responsive = TRUE)\n  )\n\n\n\n\n\n\nA better approach would be to have the geographical borders of each wine basin, and attribute each wine plot from our main dataset to a particular wine basin. However for now we did not find a geographical file corresponding to the wine basins reported in this Vineyards Cultural Practices Survey.\nWith the Vineyards Cultural Practices Survey expressed in terms of regions and not in basins, the vineyards area by basin is not relevant anymore. For the other variables, when a region is associated to multiple wine basins, we take the simple mean of the basins. This is an approximation, as we should weight the values by the respective areas, but we do not have that data..\n\n\nCode\n#create the file of wine practices by region\n\n#prepare the data frame by region basis\nferti_vineyards &lt;- keys_vineyards_basins_regions %&gt;%\n  #all (basin, regions) pairs grouped in 2 columns\n  gather(wine_basin, `wine-growing basin`, Basin_1:Basin_4) %&gt;%\n  #remove NAs lines\n  drop_na() %&gt;%\n  #remove useless column\n  select(-wine_basin)\n\n#join to the vineyards data by wine basin\nferti_vineyards &lt;-  left_join(ferti_vineyards, survey_vineyards, by=\"wine-growing basin\")\n\n#when there are mulitple basins in 1 region, take the mean of the values\nferti_vineyards &lt;- ferti_vineyards %&gt;%\n  #remove area by basin not relevant anymore\n  select(-`area (ha)`, -`wine-growing basin` ) %&gt;%\n  #group by regions and take the mean\n  group_by(code_old_region, name_old_region) %&gt;%\n  summarise_all(~mean(., na.rm = TRUE))\n#replace induced NaN by NAs\nferti_vineyards[sapply(ferti_vineyards, is.nan)] &lt;- NA\n\n#add the whole France value not catched by our lef_join : select whole France data and adds it to ferti_vineyards\ntemp &lt;- survey_vineyards %&gt;% \n  filter(`wine-growing basin` == \"France\") %&gt;%\n  select(-`area (ha)`) %&gt;%\n  rename(name_old_region = `wine-growing basin`) %&gt;%\n  mutate(code_old_region = NA)\nferti_vineyards &lt;- bind_rows(ferti_vineyards, temp)\n\n#round all the values \nferti_vineyards &lt;- ferti_vineyards %&gt;%\n    mutate_at(vars(-c(code_old_region, name_old_region)), round)\n\n\nrm(temp)\n\n\nThis regionalized data will be used in our study, to match each vineyard plot to a fertilization leval, depending on the region it belongs to.\n\n\nCode\n#add crop fertilization label to merge with main file later\nferti_vineyards &lt;- ferti_vineyards %&gt;%\n  mutate(crop_fertilization_label=\"Vignes\")\n#save final fertilization file\nf_save_csv_files(\n  ferti_vineyards, \n  \"output/fertilization/fertilization_surveys/\",\n  \"fertilization_vineyards_by_old_region.csv\")\n\n\n\n\nVizualize regionalized data in graphs\n\n\nCode\nf_graph_vineyard_by_region &lt;- function(data, variable_y, y_max, breaks_legnth, y_label, title_label){\n\n  gg &lt;- ggplot(data) +\n    geom_col(\n      aes(\n        reorder(name_old_region, {{ variable_y }}), {{ variable_y }}, \n        text = paste(\n          as.character(name_old_region), \"\\n\", \n          as.character(signif({{ variable_y }}, 3)), y_label)\n          ),\n      fill = ifelse(\n        #have to filter when missing values, for the scale\n        data %&gt;% filter(is.na({{ variable_y }})==F) %&gt;% pull(name_old_region) == \"France\", \n        \"red\", \"grey\"\n        )  # Highlight in red if \"France\"\n      ) +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1)\n    ) +\n    scale_y_continuous(\n      breaks = seq(0, y_max, by = breaks_legnth), \n      limits = c(0, NA)\n      ) +\n    labs(\n      x=\"\", color=\"\", y=y_label, title = title_label\n      ) \n  \n  return(ggplotly(gg, tooltip = c(\"text\")))\n}\n\n\n\nMean Fertilization% Fields FertilizedFertilization on fertilized fieldsYield, % Organics\n\n\n\nN minN orgP minP orgK minK org\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `N mineral mean fertilization (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"Mean N mineral fertilization\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_region(ferti_vineyards, `N organic mean fertilization (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"Mean N organic fertilization\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `P mineral mean fertilization (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"Mean P mineral fertilization\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_region(ferti_vineyards, `P organic mean fertilization (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"Mean P organic fertilization\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `K mineral mean fertilization (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"Mean K mineral fertilization\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_region(ferti_vineyards, `K organic mean fertilization (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"Mean K organic fertilization\")\n\n\n\n\n\n\n\n\nmineralorganic\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `% mineral fertilization`, 100, 10, \"%\", \"% of fields with mineral fertilization\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `% organic fertilization`, 100, 10, \"%\", \"% of fields with organic fertilization\")\n\n\n\n\n\n\n\n\n\n\n\n\nN minN orgP minP orgK minK org\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `N mineral fertilization on fertilized fields (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"N mineral fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_region(ferti_vineyards, `N organic fertilization on fertilized fields (kgN/ha)`, 100, 5, \"(kgN/ha)\", \"N organic fertilization on fertilized fields\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `P mineral fertilization on fertilized fields (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"P mineral fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_region(ferti_vineyards, `P organic fertilization on fertilized fields (kgP/ha)`, 100, 1, \"(kgP/ha)\", \"P organic fertilization on fertilized fields\")\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `K mineral fertilization on fertilized fields (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"K mineral fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nunderstand problem with graph function\n\n\nCode\n# f_graph_vineyard_by_region(ferti_vineyards, `K organic fertilization on fertilized fields (kgK/ha)`, 100, 5, \"(kgK/ha)\", \"K organic fertilization on fertilized fields\")\n\n\n\n\n\n\n\n\nyield% organic\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `yield (hl/ha)`, 100, 10, \"hl/ha\", \"Yield by wine-growing basin\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_vineyard_by_region(ferti_vineyards, `% fields organic`, 100, 10, \"%\", \"% of fields in organic agriculture\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExplore regionalized data in a table\nBesides the graphs above, you can also interactively explore the data in the table below.\n\n\nCode\ndatatable(\n  ferti_vineyards, options = list(scrollX = TRUE, responsive = TRUE)\n)\n\n\n\n\n\n\n\n\nCode\n#remove temporary files\nrm(keys_vineyards_basins_regions)\n\n\n\n\nCode\n#save graphs for manuscript\n\n#function to prepare mineral and organic N ferti, by wine-growin basin or Franch region\nf_prepare &lt;- function(dataset, region){\n  #focus on N mineral and organic ferti\n  dataset &lt;- dataset %&gt;%\n    ungroup() %&gt;%\n    select({{ region }}, `mineral fertilization` = `N mineral mean fertilization (kgN/ha)`, `organic fertilization` = `N organic mean fertilization (kgN/ha)`) %&gt;%\n    gather(variable, value, -{{ region }})\n  \n  # Reorder by ascending mineral value\n  dataset &lt;- dataset %&gt;%\n    mutate({{ region }} := factor(\n      {{ region }},\n      levels = dataset %&gt;% filter(variable == \"mineral fertilization\") %&gt;% arrange(desc(value)) %&gt;% pull({{ region }})\n    ))\n  \n  return(dataset)\n}\n\n#function for vineyards fertilization manuscript graph\nf_graph &lt;- function(dataset, region, title_label){\n  #graph\n  gg &lt;- ggplot(dataset) +\n      geom_col(\n        aes({{ region }}, value),\n        fill = ifelse(# Highlight in red if \"France\"\n          dataset %&gt;% pull({{ region }}) == \"France\", \n          \"red\", \"grey\"\n          )  \n        ) +\n      geom_text(\n        aes({{ region }}, value, label = value),\n        hjust=-0.2, fontface=\"italic\"\n        ) +\n      theme(\n        axis.text.x = element_text(angle = 45, hjust = 1)\n      ) +\n      scale_y_continuous(\n        breaks = seq(0, 100, by = 5), \n        limits = c(0, 50)\n        ) +\n      labs(\n        x=\"\", color=\"\", y=\"kgN/ha\", subtitle = title_label\n        ) +\n    facet_wrap(vars(variable), ) +\n    coord_flip()\n  \n  return(gg)\n  \n}\n\n#graph wine growing regions\ntemp &lt;- f_prepare(survey_vineyards, `wine-growing basin`)\ngg1 &lt;- f_graph(temp, `wine-growing basin`, \"by wine-growing basin\")\n\n#graph French regions\ntemp &lt;- f_prepare(ferti_vineyards, name_old_region)\ngg2 &lt;- f_graph(temp, name_old_region, \"by French region\")\n\n\ngg &lt;- gg1 + gg2 +plot_layout(ncol = 1)\ngg\n\n\n\n\n\n\n\n\n\nCode\nf_save_graph_pdf_png(\n  gg, \"graph/fertilization_values/\", \"vineyards_fertilization\",\n  350, 9, 7\n)"
  },
  {
    "objectID": "0_cultural_practices_surveys.html#estimation-share-mineral-organic-fertilization",
    "href": "0_cultural_practices_surveys.html#estimation-share-mineral-organic-fertilization",
    "title": "Fertilizations Values",
    "section": "Estimation share mineral / organic fertilization",
    "text": "Estimation share mineral / organic fertilization\nThe figures mentioned above only concern the fertilization “requirements”. However that does not specify how much of this is fulfilled with mineral fertilizers. We hypothesize an order of magnitude, based on the distribution between organic and mineral fertilizer in major crops and vineyards.\nFor vineyards, mineral nitrogen is about 50% of total fertilization.\nFor major crops, most of them are about 75% mineral N or above. The exceptions are: leguminous crops (féverole, pois protéagineux, soja), at most 25%, and livestock fodder (ma¨s fourrage and prairies permanentes) around 50%.\nFor the following, we will take as an order of magnitude 66% of crops needs covered by mineral fertilization.\n\nMajor cropsVineyards\n\n\n\n\nCode\n#take major crops values and compute distribution between mineral and organic\ntemp &lt;- survey_major_crops %&gt;%\n  select(\n    crop_fertilization_label,\n    name_old_region,\n    Nmin = `N mineral mean fertilization (kgN/ha)`,\n    Norg = `N organic mean fertilization (kgN/ha)`\n    )  %&gt;%\n  mutate(\n    percent_N_mineral = round(Nmin/(Nmin+Norg), 2)*100\n  )\n\n#vizualize result\ngg_major &lt;- ggplot(temp) +\n  geom_point(\n    aes(reorder(crop_fertilization_label, percent_N_mineral),\n        percent_N_mineral, color=name_old_region),\n    position = position_nudge(x = .2), alpha=.4\n    ) +\n  geom_boxplot(\n    aes(reorder(crop_fertilization_label, percent_N_mineral), percent_N_mineral),\n    position = position_nudge(x = -.2), width = .4\n    ) +\n  theme(\n    axis.text.x = element_text(angle=45, h=1),\n    ) +\n  scale_y_continuous(labels = scales::label_percent(scale = 1)) +\n  labs(x=\"\", y=\"% N mineral fertilization\", fill=\"(old) region\")\n\nggplotly(gg_major)\n\n\n\n\n\n\n\n\n\n\nCode\n#take major crops values and compute distribution between mineral and organic\ntemp &lt;- survey_vineyards %&gt;%\n  select(\n    `wine-growing basin`,\n    Nmin = `N mineral mean fertilization (kgN/ha)` ,\n    Norg = `N organic mean fertilization (kgN/ha)`,\n    Pmin = `P mineral mean fertilization (kgP/ha)` ,\n    Porg = `P organic mean fertilization (kgP/ha)`,\n    Kmin = `K mineral mean fertilization (kgK/ha)` ,\n    Korg = `K organic mean fertilization (kgK/ha)`,\n    ) %&gt;%\n  mutate(\n    nitrogen = round(Nmin/(Nmin+Norg), 2)*100,\n    phosphorus = round(Pmin/(Pmin+Porg), 2)*100,\n    potassium = round(Kmin/(Kmin+Korg), 2)*100\n  ) %&gt;%\n  select(`wine-growing basin`, nitrogen, phosphorus, potassium) %&gt;%\n  gather(mineral, value, -`wine-growing basin`)\n\n#vizualize result\ngg_vineyards &lt;- ggplot(temp) +\n  geom_point(\n    aes(\n      value,\n      reorder(`wine-growing basin`, value), color=mineral\n      )\n    ) +\n  theme(\n    axis.text.x = element_text(angle=45, h=1),\n    ) +\n  scale_x_continuous(\n    labels = scales::label_percent(scale = 1)\n    ) +\n  labs(\n    x=\"% mineral fertilization\", y=\"\", fill=\"nutrient\",\n    title = \"\"\n    )\nggplotly(gg_vineyards)\n\n\n\n\n\n\nCode\nggplot(temp) +\n  geom_boxplot(aes(mineral, value, fill=mineral), alpha=.7) +\n  theme(axis.text.x = element_text(angle=45, h=1)) +\n  labs(x=\"\", y=\"% N mineral\")\n\n\n\n\n\n\n\n\n\n\n\nCode\n#save for manuscript\n\ngg &lt;- \n  #vineyards graph\n  gg_vineyards  + labs(color = \"nutrient\", y=\"wine-growing basin\") + \n  theme(legend.position = c(0.2, 0.8)) +\n  #major crops graph\n  gg_major +  labs(x=\"crop\", subtitle = \"each dot is a region\") + coord_flip() + theme(legend.position = \"none\")\ngg\n\n\n\n\n\n\n\n\n\nCode\nf_save_graph_pdf_png(\n  gg, \"graph/fertilization_values/\", \"percent_mineral\",\n  350, 4, 10\n)\n\n#remove temporary variable\nrm(temp, gg_vineyards, gg_major)"
  },
  {
    "objectID": "0_cultural_practices_surveys.html#orchards",
    "href": "0_cultural_practices_surveys.html#orchards",
    "title": "Fertilizations Values",
    "section": "Orchards",
    "text": "Orchards\nHere we present the values we use for Orchards mineral fertilization, based on page 58 of the report. We do not include grapes, which are already in the vineyards data.\nNote that our values are only 2/3 of the report values, since we estimate that mineral fertilization represents about 2/3 of the crops “requirements”.\n\n\nCode\n#load values\nferti_orchards &lt;- read_csv(\"source/fertilization/AND_international_estimations/fertilization_requirements_orchards.csv\")\n\n#values *2/3, share of mineral fertilization\nferti_orchards &lt;- ferti_orchards %&gt;%\n  mutate(\n    `N mineral mean fertilization (kgN/ha)` = `kgN/ha`*2/3,\n    `P mineral mean fertilization (kgP/ha)` = `kgP/ha`*2/3,\n    `K mineral mean fertilization (kgK/ha)` = `kgK/ha`*2/3,\n    `N organic mean fertilization (kgN/ha)` = `kgN/ha`*1/3\n  ) %&gt;%\n  select(-`kgN/ha`, -`kgP/ha`, -`kgK/ha`)\n\n#save values\nf_save_csv_files(\n  ferti_orchards, \n  \"output/fertilization/\",\n  \"fertilization_orchards_by_crop.csv\"\n  )\n\n#graph function to see the values\nf_graph_orchards &lt;- function(data, variable_y, y_max, breaks_legnth, y_label, title_label){\n\n  gg &lt;- ggplot(data) +\n    geom_col(\n      aes(\n        reorder(crop_fertilization_label, {{ variable_y }}), {{ variable_y }}, \n        text = paste(\n          as.character(crop_fertilization_label), \"\\n\", \n          as.character(signif({{ variable_y }}, 3)), y_label)\n          )\n      ) +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1)\n      ) +\n    scale_y_continuous(\n      breaks = seq(0, y_max, by = breaks_legnth),\n      limits = c(0, NA)\n      ) +\n    labs(\n      x=\"\", color=\"\", y=y_label, title = title_label\n      ) \n  \n  return(ggplotly(gg, tooltip = c(\"text\")))\n}\n\n\n\n\nCode\n#plot N for manuscript\ntemp &lt;- ferti_orchards %&gt;% \n  select(crop_fertilization_label, \n         mineral = `N mineral mean fertilization (kgN/ha)`,\n         organic = `N organic mean fertilization (kgN/ha)`\n         ) %&gt;%\n  mutate(\n    total = mineral + organic\n    ) %&gt;%\n  gather(type, value, mineral, organic)\n\ntemp$type &lt;- factor(temp$type, levels = c(\"organic\", \"mineral\"))\n\ngg &lt;- ggplot(temp) +\n  geom_col(\n    aes(value, reorder(crop_fertilization_label, value), fill = type),\n    alpha=.7\n    ) +\n  geom_text(\n    aes(total, crop_fertilization_label, label = round(total)),\n    hjust = 0\n    ) +\n  theme(\n    panel.grid.major.x = element_line(),\n    panel.grid.minor.x = element_line(),\n    panel.grid.major.y = element_blank()\n    ) +\n  scale_x_continuous(\n    limits = c(0, 200),\n    breaks = seq(0, 200, 20),\n    minor_breaks = seq(0, 200, 10)\n    ) +\n  labs(fill=\"fertilization\", x=\"kgN/ha\", y=\"\")\n\nf_save_graph_pdf_png(\n  gg, \"graph/fertilization_values/\", \"orchards_fertilization_by_crops\",\n  350, 3, 6\n)\n\n\n\nN mineralP mineralK mineral\n\n\n\n\nCode\nf_graph_orchards(ferti_orchards, `N mineral mean fertilization (kgN/ha)`, 450, 50, \"kgN/ha\", \"Orchards N fertilization requirements\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_orchards(ferti_orchards, `P mineral mean fertilization (kgP/ha)`, 150, 20, \"kgP/ha\", \"Orchards P fertilization requirements\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_orchards(ferti_orchards, `K mineral mean fertilization (kgK/ha)`, 500, 50, \"kgK/ha\", \"Orchards N fertilization requirements\")"
  },
  {
    "objectID": "0_cultural_practices_surveys.html#vegetables-and-floral-crops",
    "href": "0_cultural_practices_surveys.html#vegetables-and-floral-crops",
    "title": "Fertilizations Values",
    "section": "Vegetables and Floral Crops",
    "text": "Vegetables and Floral Crops\nHere we present the values we use for Vegetables and Floral Crops mineral fertilization, based on page 54 of the report. We also include mustard (p50) and tobacco (p59)\nNote that our values are only 2/3 of the report values, since we estimate that mineral fertilization represents about 2/3 of the crops “requirements”.\n\n\nCode\n#load values\nferti_vegetables_floral &lt;- read_csv(\"source/fertilization/AND_international_estimations/fertilization_requirements_vegetables_floral.csv\")\n\n#values *2/3, share of mineral fertilization\nferti_vegetables_floral &lt;- ferti_vegetables_floral %&gt;%\n  mutate(\n    `N mineral mean fertilization (kgN/ha)` = `kgN/ha`*2/3,\n    `P mineral mean fertilization (kgP/ha)` = `kgP/ha`*2/3,\n    `K mineral mean fertilization (kgK/ha)` = `kgK/ha`*2/3,\n    `N organic mean fertilization (kgN/ha)` = `kgN/ha`*1/3\n  ) %&gt;%\n  select(-`kgN/ha`, -`kgP/ha`, -`kgK/ha`)\n\n#save values\nf_save_csv_files(\n  ferti_vegetables_floral, \n  \"output/fertilization/\",\n  \"fertilization_vegetables_floral.csv\"\n  )\n\n#graph function to see the values\nf_graph_vegetables_floral &lt;- function(data, variable_y, y_max, breaks_legnth, y_label, title_label){\n\n  gg &lt;- ggplot(data) +\n    geom_col(\n      aes(\n        reorder(crop_fertilization_label, {{ variable_y }}), {{ variable_y }}, \n        text = paste(\n          as.character(crop_fertilization_label), \"\\n\", \n          as.character(signif({{ variable_y }}, 3)), y_label)\n          )\n      ) +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1)\n      ) +\n    scale_y_continuous(\n      breaks = seq(0, y_max, by = breaks_legnth),\n      limits = c(0, NA)\n      ) +\n    labs(\n      x=\"\", color=\"\", y=y_label, title = title_label\n      ) \n  \n  return(ggplotly(gg, tooltip = c(\"text\")))\n}\n\n\n\n\nCode\n#plot N for manuscript\ntemp &lt;- ferti_vegetables_floral %&gt;% \n  select(crop_fertilization_label, \n         mineral = `N mineral mean fertilization (kgN/ha)`,\n         organic = `N organic mean fertilization (kgN/ha)`\n         ) %&gt;%\n  mutate(\n    total = mineral + organic\n    ) %&gt;%\n  gather(type, value, mineral, organic)\n\ntemp$type &lt;- factor(temp$type, levels = c(\"organic\", \"mineral\"))\n\ngg &lt;- ggplot(temp) +\n  geom_col(\n    aes(value, reorder(crop_fertilization_label, value), fill = type),\n    alpha=.7\n    ) +\n  geom_text(\n    aes(total, crop_fertilization_label, label = round(total)),\n    hjust = 0\n    ) +\n  theme(\n    panel.grid.major.x = element_line(),\n    panel.grid.minor.x = element_line(),\n    panel.grid.major.y = element_blank()\n    ) +\n  scale_x_continuous(\n    limits = c(0, 500),\n    breaks = seq(0, 500, 100),\n    minor_breaks = seq(0, 500, 50)\n    ) +\n  labs(fill=\"fertilization\", x=\"kgN/ha\", y=\"\")\n\nf_save_graph_pdf_png(\n  gg, \"graph/fertilization_values/\", \"vegetables_floral_fertilization_by_crops\",\n  350, 3, 6\n)\n\n\n\nN mineralP mineralK mineral\n\n\n\n\nCode\nf_graph_vegetables_floral(ferti_vegetables_floral, `N mineral mean fertilization (kgN/ha)`, 450, 50, \"kgN/ha\", \"Vegetables and floral crops N fertilization requirements\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_vegetables_floral(ferti_vegetables_floral, `P mineral mean fertilization (kgP/ha)`, 150, 20, \"kgP/ha\", \"Vegetables and floral crops P fertilization requirements\")\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_vegetables_floral(ferti_vegetables_floral, `K mineral mean fertilization (kgK/ha)`, 500, 50, \"kgK/ha\", \"Vegetables and floral crops N fertilization requirements\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "This website describes how to get the results presented in Chapter 6 of Starck (2024). The results here go beyond what is presented in the articles.\nThis project estimates N, P and K fertilization at fine spatial resolutions (agricultural parcel level) in France. Multiple sources are used: the RPG database (Registre Parcellaire Graphique) and the TOPO database for the spatial distribution of crops; and the French Enquêtes Pratiques Culturales to estimate fertilization on each agricultural parcel. They are presented in the tab Data Source Presentation.\nThe computation are quite heavy, and are performed for each region in the tab Prepare ferttilization.\nThe actual results are displayed in Results, presenting estimates of the fertilization in the current situation, but also in an agro-ecological scenario with low fertilization inputs. I also produce a spatially explicit estimation of the nutrient excreted by French people, which, coupled with the fertilization estimates, is used to assess the distances between excretions and fertilization (see details in Chapter 6 of Starck (2024)).\nThe code to generate the results and website is accessible on this github repository; it is associated to a permanent repository on zenodo at https://doi.org/10.5281/zenodo.14605711. As the source and output data are on the order of 1-10 GB and could not be commited to the github repository, they are stored on an additional zenodo repository at https://doi.org/10.5281/zenodo.14605243.\n\n\n\n\nReferences\n\nStarck, Thomas. 2024. “Towards a Circular Management of Nitrogen and Phosphorus in Human Excreta: Current State, Global Agricultural Potential, and Spatial Constraint in France.” PhD thesis, Ecole nationale des ponts et chaussées. https://hal.science/tel-04727806."
  },
  {
    "objectID": "0_crops_keys.html",
    "href": "0_crops_keys.html",
    "title": "Crop Keys",
    "section": "",
    "text": "Code\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='svg')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load additional required libraries\nlibrary(DT) #for interactive tables\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    panel.grid.minor.y = element_line(linewidth = 0.5)\n    )\n  )"
  },
  {
    "objectID": "0_crops_keys.html#understand-crops-and-crops-groups-keys",
    "href": "0_crops_keys.html#understand-crops-and-crops-groups-keys",
    "title": "Crop Keys",
    "section": "Understand crops and crops groups keys",
    "text": "Understand crops and crops groups keys\nhere are the crops (all, including before 2015) not present in crops groups. Coherent, all end before 2015, justifies the choice to only select those before 2015.\ncelui seul en 2019 et sans fin : CNA Châtaigneraie non entretenue par des porcins\nattention 2 qui se “finissent” en 1900 (début 2015) : BCC banane créole et CSC canne à sucre =&gt; changer date de fin en NA ?\n\n\nCode\ntemp2 &lt;- anti_join(keys_crops_all, keys_crops_groups, by=join_by(CODE == CODE_CULTURE))\n\nggplot(temp2) +\n  geom_histogram(aes(CAMPAGNE_FIN, fill=\"end year\"), alpha=.4) +\n  geom_histogram(aes(CAMPAGNE_DEBUT, fill=\"begin year\"), alpha=.4) +\n  xlim(2000, 2020) +\n  labs(x=\"\", fill=\"\")\n\n\n\n\n\n\n\n\n\nAmong the crops included in crops groups,\n\n\nCode\ntemp &lt;- left_join(keys_crops_groups, keys_crops, by=join_by(CODE_CULTURE == CODE))\n\n\n#donc on se focus que sur celle des main crops groups\nno_end &lt;- nrow(temp %&gt;% filter(is.na(CAMPAGNE_FIN)))\nend &lt;- nrow(temp %&gt;% filter(is.na(CAMPAGNE_FIN)==F))\nggplot(temp) +\n  geom_histogram(aes(CAMPAGNE_FIN, fill=\"end year\"), alpha=.4) +\n  geom_histogram(aes(CAMPAGNE_DEBUT, fill=\"begin year\"), alpha=.4) +\n  labs(\n    x=\"\", fill=\"\",\n    subtitle = paste(no_end, \"crops keys have no end year,\", end, \"have one\")\n      )\n\n\n\n\n\n\n\n\n\nCode\n#so we focus on \n#Check if same crops names in the 2 files\ntemp2 &lt;- temp %&gt;% filter(LIBELLE_CULTURE.x != LIBELLE_CULTURE.y) %&gt;%\n  select(LIBELLE_CULTURE.x, LIBELLE_CULTURE.y)\n#OK, only minor difference (accent, uppercase, etc...)\n\n\nkeys_crops_and_groups &lt;- temp %&gt;% \n  select(-LIBELLE_CULTURE.y) %&gt;% rename(LIBELLE_CULTURE = LIBELLE_CULTURE.x)\n\nrm(temp, temp2)"
  },
  {
    "objectID": "0_excretions.html",
    "href": "0_excretions.html",
    "title": "Excretions",
    "section": "",
    "text": "TO BE DONE :\n\nreorder preparation and map beginning\n\najouter nom régions et départements\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file common to all pages\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\nlibrary(arrow) #to read and write parquet file, and set objects to arrow tables\nlibrary(sf)\nlibrary(cowplot)\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS_RGF93_Lambert93 &lt;- 2154 # number of coordinate projection system used for France (Réseau Géodésique Français 1993 - Lambert 93)\n\n# molar mass K : 39, O : 16\nK2O_K_conversion_factor &lt;- (2*39)/(2*39+16)\n# molar mass P : 31, O : 16\nP2O5_P_conversion_factor &lt;- (2*31)/(2*31+5*16)\n\n\n\n\nCode\n#load map regions and create a whole France polygon from this\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_france &lt;- st_union(sf_regions)\n#simplify polygon for faster plotting\nsf_france &lt;- st_simplify(sf_france, 100, preserveTopology = T)\nrm(sf_regions)\n\n#load map communes\nsf_communes &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/COMMUNE.shp\")\n#keep columns of interest from \nsf_communes &lt;- sf_communes %&gt;% select(\n  code_commune = INSEE_COM, name_commune = NOM_COM, \n  code_department = INSEE_DEP, code_region = INSEE_REG,\n  population_sf = POPULATION\n  )\n\n\n#load map old regions and convert it into our Coordinate Reference System\nsf_old_regions &lt;- sf::st_read(\"/Users/thomasstarck/Desktop/sites/spatial-excretions-fertilization/source/maps/old_regions/regions-20140306-5m.shp\")\nsf_old_regions &lt;- st_transform(sf_old_regions, CRS_RGF93_Lambert93)\n\n\n\nLoad and prepare data\n\nPopulation by communesPopulation at 1 km2 resolutionComparison of the 2 datasetsMerge the 2 datasets information and prepare 4km2 data\n\n\nI convert the population in each French commune to nutrient excretions. This is obtained by combining population data with data reported in the INCA3 study, that I already investigated in a previous project (see figures in Nutrient intakes by age and sex -&gt; Tables).\nPopulation data by commune and by age comes from INSEE, and its reference year is 2018.\n\n\nCode\n#load file\npopulation_communes &lt;- \n  readxl::read_excel(\n    \"source/population/population_by_commune/pop-sexe-age-quinquennal6818.xls\", \n    sheet = \"COM_2018\",skip=13\n    )\n\n# check factors here https://thomas-starck.github.io/n-p-sanitation-flows/0_nutrient_excretions.html in Nutrient intakes by age and sex -&gt; Tables\n\npopulation_communes &lt;- population_communes %&gt;%\n  mutate(\n    \n    #  Nitrogen\n    \n    # MEN\n    N_inca_men_0_1 = 0.88*ageq_rec01s1rpop2018/5, #0 to 4 years, 1/5\n    N_inca_men_1_3 = 2.58*ageq_rec01s1rpop2018*4/5, #0 to 4 years, 4/5\n    N_inca_men_4_6 = 3.33*ageq_rec02s1rpop2018*2/5, #5 to 9 years, 2/5\n    N_inca_men_7_10 = 4.16*ageq_rec02s1rpop2018*3/5, #5 to 9 years, 3/5\n    N_inca_men_11_14 = 4.67*ageq_rec03s1rpop2018, #10 to 14 years\n    N_inca_men_15_17 = 5.18*ageq_rec04s1rpop2018, #15 to 19 years\n    N_inca_men_18_44 = 5.48*(ageq_rec05s1rpop2018 + ageq_rec06s1rpop2018 + ageq_rec07s1rpop2018 + ageq_rec08s1rpop2018 + ageq_rec09s1rpop2018), #20 to 44 years, by 5-year categories\n    N_inca_men_45_64 = 5.62*(ageq_rec10s1rpop2018 + ageq_rec11s1rpop2018 + ageq_rec12s1rpop2018 + ageq_rec13s1rpop2018), #45 to 64 years, by 5-year categories\n    N_inca_men_65_79 = 5.29*(ageq_rec14s1rpop2018 + ageq_rec15s1rpop2018 + ageq_rec16s1rpop2018 + ageq_rec17s1rpop2018 + ageq_rec18s1rpop2018 + ageq_rec19s1rpop2018 + ageq_rec20s1rpop2018),#45 to &gt;95 years, by 5-year categories\n    \n    # WOMEN, nitrogen\n    N_inca_women_0_1 = 0.949*ageq_rec01s2rpop2018/5, #0 to 4 years, 1/5\n    N_inca_women_1_3 = 2.51*ageq_rec01s2rpop2018*4/5, #0 to 4 years, 4/5\n    N_inca_women_4_6 = 3.18*ageq_rec02s2rpop2018*2/5, #5 to 9 years, 2/5\n    N_inca_women_7_10 = 3.76*ageq_rec02s2rpop2018*3/5, #5 to 9 years, 3/5\n    N_inca_women_11_14 = 4.09*ageq_rec03s2rpop2018, #10 to 14 years\n    N_inca_women_15_17 = 3.83*ageq_rec04s2rpop2018, #15 to 19 years\n    N_inca_women_18_44 = 4.12*(ageq_rec05s2rpop2018 + ageq_rec06s2rpop2018 + ageq_rec07s2rpop2018 + ageq_rec08s2rpop2018 + ageq_rec09s2rpop2018), #20 to 44 years, by 5-year categories\n    N_inca_women_45_64 = 4.34*(ageq_rec10s2rpop2018 + ageq_rec11s2rpop2018 + ageq_rec12s2rpop2018 + ageq_rec13s2rpop2018), #45 to 64 years, by 5-year categories\n    N_inca_women_65_79 = 4.05*(ageq_rec14s2rpop2018 + ageq_rec15s2rpop2018 + ageq_rec16s2rpop2018 + ageq_rec17s2rpop2018 + ageq_rec18s2rpop2018 + ageq_rec19s2rpop2018 + ageq_rec20s2rpop2018),#45 to &gt;95 years, by 5-year categories\n    \n    \n    \n    #  Phosphorus\n    \n    # MEN\n    P_inca_men_0_1 = 0.134*ageq_rec01s1rpop2018/5, #0 to 4 years, 1/5\n    P_inca_men_1_3 = 0.303*ageq_rec01s1rpop2018*4/5, #0 to 4 years, 4/5\n    P_inca_men_4_6 = 0.361*ageq_rec02s1rpop2018*2/5, #5 to 9 years, 2/5\n    P_inca_men_7_10 = 0.434*ageq_rec02s1rpop2018*3/5, #5 to 9 years, 3/5\n    P_inca_men_11_14 = 0.467*ageq_rec03s1rpop2018, #10 to 14 years\n    P_inca_men_15_17 = 0.5*ageq_rec04s1rpop2018, #15 to 19 years\n    P_inca_men_18_44 = 0.515*(ageq_rec05s1rpop2018 + ageq_rec06s1rpop2018 + ageq_rec07s1rpop2018 + ageq_rec08s1rpop2018 + ageq_rec09s1rpop2018), #20 to 44 years, by 5-year categories\n    P_inca_men_45_64 = 0.518*(ageq_rec10s1rpop2018 + ageq_rec11s1rpop2018 + ageq_rec12s1rpop2018 + ageq_rec13s1rpop2018), #45 to 64 years, by 5-year categories\n    P_inca_men_65_79 = 0.482*(ageq_rec14s1rpop2018 + ageq_rec15s1rpop2018 + ageq_rec16s1rpop2018 + ageq_rec17s1rpop2018 + ageq_rec18s1rpop2018 + ageq_rec19s1rpop2018 + ageq_rec20s1rpop2018),#45 to &gt;95 years, by 5-year categories\n    \n    # WOMEN, nitrogen\n    P_inca_women_0_1 = 0.142*ageq_rec01s2rpop2018/5, #0 to 4 years, 1/5\n    P_inca_women_1_3 = 0.296*ageq_rec01s2rpop2018*4/5, #0 to 4 years, 4/5\n    P_inca_women_4_6 = 0.346*ageq_rec02s2rpop2018*2/5, #5 to 9 years, 2/5\n    P_inca_women_7_10 = 0.387*ageq_rec02s2rpop2018*3/5, #5 to 9 years, 3/5\n    P_inca_women_11_14 = 0.412*ageq_rec03s2rpop2018, #10 to 14 years\n    P_inca_women_15_17 = 0.383*ageq_rec04s2rpop2018, #15 to 19 years\n    P_inca_women_18_44 = 0.405*(ageq_rec05s2rpop2018 + ageq_rec06s2rpop2018 + ageq_rec07s2rpop2018 + ageq_rec08s2rpop2018 + ageq_rec09s2rpop2018), #20 to 44 years, by 5-year categories\n    P_inca_women_45_64 = 0.409*(ageq_rec10s2rpop2018 + ageq_rec11s2rpop2018 + ageq_rec12s2rpop2018 + ageq_rec13s2rpop2018), #45 to 64 years, by 5-year categories\n    P_inca_women_65_79 = 0.376*(ageq_rec14s2rpop2018 + ageq_rec15s2rpop2018 + ageq_rec16s2rpop2018 + ageq_rec17s2rpop2018 + ageq_rec18s2rpop2018 + ageq_rec19s2rpop2018 + ageq_rec20s2rpop2018),#45 to &gt;95 years, by 5-year categories\n    \n    \n    \n    #  Potassium\n    \n    # MEN\n    K_inca_men_0_1 = 0.286*ageq_rec01s1rpop2018/5, #0 to 4 years, 1/5\n    K_inca_men_1_3 = 0.675*ageq_rec01s1rpop2018*4/5, #0 to 4 years, 4/5\n    K_inca_men_4_6 = 0.803*ageq_rec02s1rpop2018*2/5, #5 to 9 years, 2/5\n    K_inca_men_7_10 = 0.964*ageq_rec02s1rpop2018*3/5, #5 to 9 years, 3/5\n    K_inca_men_11_14 = 1.03*ageq_rec03s1rpop2018, #10 to 14 years\n    K_inca_men_15_17 = 1.07*ageq_rec04s1rpop2018, #15 to 19 years\n    K_inca_men_18_44 = 1.21*(ageq_rec05s1rpop2018 + ageq_rec06s1rpop2018 + ageq_rec07s1rpop2018 + ageq_rec08s1rpop2018 + ageq_rec09s1rpop2018), #20 to 44 years, by 5-year categories\n    K_inca_men_45_64 = 1.34*(ageq_rec10s1rpop2018 + ageq_rec11s1rpop2018 + ageq_rec12s1rpop2018 + ageq_rec13s1rpop2018), #45 to 64 years, by 5-year categories\n    K_inca_men_65_79 = 1.27*(ageq_rec14s1rpop2018 + ageq_rec15s1rpop2018 + ageq_rec16s1rpop2018 + ageq_rec17s1rpop2018 + ageq_rec18s1rpop2018 + ageq_rec19s1rpop2018 + ageq_rec20s1rpop2018),#45 to &gt;95 years, by 5-year categories\n    \n    # WOMEN, nitrogen\n    K_inca_women_0_1 = 0.315*ageq_rec01s2rpop2018/5, #0 to 4 years, 1/5\n    K_inca_women_1_3 = 0.628*ageq_rec01s2rpop2018*4/5, #0 to 4 years, 4/5\n    K_inca_women_4_6 = 0.785*ageq_rec02s2rpop2018*2/5, #5 to 9 years, 2/5\n    K_inca_women_7_10 = 0.85*ageq_rec02s2rpop2018*3/5, #5 to 9 years, 3/5\n    K_inca_women_11_14 = 0.92*ageq_rec03s2rpop2018, #10 to 14 years\n    K_inca_women_15_17 = 0.876*ageq_rec04s2rpop2018, #15 to 19 years\n    K_inca_women_18_44 = 0.986*(ageq_rec05s2rpop2018 + ageq_rec06s2rpop2018 + ageq_rec07s2rpop2018 + ageq_rec08s2rpop2018 + ageq_rec09s2rpop2018), #20 to 44 years, by 5-year categories\n    K_inca_women_45_64 = 1.09*(ageq_rec10s2rpop2018 + ageq_rec11s2rpop2018 + ageq_rec12s2rpop2018 + ageq_rec13s2rpop2018), #45 to 64 years, by 5-year categories\n    K_inca_women_65_79 = 1.04*(ageq_rec14s2rpop2018 + ageq_rec15s2rpop2018 + ageq_rec16s2rpop2018 + ageq_rec17s2rpop2018 + ageq_rec18s2rpop2018 + ageq_rec19s2rpop2018 + ageq_rec20s2rpop2018),#45 to &gt;95 years, by 5-year categories\n    \n    \n    # Add all ages categories\n    \n    #      population\n    population =\n      #men\n      ageq_rec01s1rpop2018 + ageq_rec02s1rpop2018 + ageq_rec03s1rpop2018 + ageq_rec04s1rpop2018 + ageq_rec05s1rpop2018 + ageq_rec06s1rpop2018 + ageq_rec07s1rpop2018 + ageq_rec08s1rpop2018 + ageq_rec09s1rpop2018 + ageq_rec10s1rpop2018 + ageq_rec11s1rpop2018 + ageq_rec12s1rpop2018 + ageq_rec13s1rpop2018 + ageq_rec14s1rpop2018 + ageq_rec15s1rpop2018 + ageq_rec16s1rpop2018 + ageq_rec17s1rpop2018 + ageq_rec18s1rpop2018 + ageq_rec19s1rpop2018 + ageq_rec20s1rpop2018 +\n      #women\n      ageq_rec01s2rpop2018 + ageq_rec02s2rpop2018 + ageq_rec03s2rpop2018 + ageq_rec04s2rpop2018 + ageq_rec05s2rpop2018 + ageq_rec06s2rpop2018 + ageq_rec07s2rpop2018 + ageq_rec08s2rpop2018 + ageq_rec09s2rpop2018 + ageq_rec10s2rpop2018 + ageq_rec11s2rpop2018 + ageq_rec12s2rpop2018 + ageq_rec13s2rpop2018 + ageq_rec14s2rpop2018 + ageq_rec15s2rpop2018 + ageq_rec16s2rpop2018 + ageq_rec17s2rpop2018 + ageq_rec18s2rpop2018 + ageq_rec19s2rpop2018 + ageq_rec20s2rpop2018,\n    \n    #       nitrogen\n    kgN_excretions = \n      #men\n      N_inca_men_0_1 + N_inca_men_1_3 + N_inca_men_4_6 + N_inca_men_7_10 + N_inca_men_11_14 + N_inca_men_15_17 + N_inca_men_18_44 + N_inca_men_45_64 + N_inca_men_65_79 +\n      #women\n      N_inca_women_0_1 + N_inca_women_1_3 + N_inca_women_4_6 + N_inca_women_7_10 + N_inca_women_11_14 + N_inca_women_15_17 + N_inca_women_18_44 + N_inca_women_45_64 + N_inca_women_65_79,\n    \n    #       phosphorus\n    kgP_excretions = \n      #men\n      P_inca_men_0_1 + P_inca_men_1_3 + P_inca_men_4_6 + P_inca_men_7_10 + P_inca_men_11_14 + P_inca_men_15_17 + P_inca_men_18_44 + P_inca_men_45_64 + P_inca_men_65_79 +\n      #women\n      P_inca_women_0_1 + P_inca_women_1_3 + P_inca_women_4_6 + P_inca_women_7_10 + P_inca_women_11_14 + P_inca_women_15_17 + P_inca_women_18_44 + P_inca_women_45_64 + P_inca_women_65_79,\n    \n    #      potassium\n    kgK_excretions = \n      #men\n      K_inca_men_0_1 + K_inca_men_1_3 + K_inca_men_4_6 + K_inca_men_7_10 + K_inca_men_11_14 + K_inca_men_15_17 + K_inca_men_18_44 + K_inca_men_45_64 + K_inca_men_65_79 +\n      #women\n      K_inca_women_0_1 + K_inca_women_1_3 + K_inca_women_4_6 + K_inca_women_7_10 + K_inca_women_11_14 + K_inca_women_15_17 + K_inca_women_18_44 + K_inca_women_45_64 + K_inca_women_65_79,\n    \n    \n    # and finally create code commune based on department and commune codes\n    \n    code_commune = paste0(DR, CR)\n    \n  ) %&gt;%\n  \n  select(\n    code_region = RR, code_department = DR, code_commune, name_commune = LIBELLE, \n    population, kgN_excretions, kgP_excretions, kgK_excretions\n  )\n\n\nThe 20 Parisian arrondissements are merged into 1 commune, and overseas territories are removed.\n\n\nCode\n#have to merge Paris arrondissements in 1 unique commune\n#first we merge the arrondissements in one temporary file. 75056 is the code for Paris in the map file\ntemp &lt;- population_communes %&gt;% filter(\n  code_commune %in% c(\n    \"75101\", \"75102\", \"75103\", \"75104\", \"75105\", \"75106\", \"75107\", \"75108\", \"75109\", \"75110\",\n    \"75111\", \"75112\", \"75113\", \"75114\", \"75115\", \"75116\", \"75117\", \"75118\", \"75119\", \"75120\")) %&gt;%\n  mutate(code_commune = \"75056\", name_commune = \"Paris\") %&gt;%\n  group_by(code_region, code_department, code_commune, name_commune) %&gt;%\n  summarise(\n    population = sum(population, na.rm = T),\n    kgN_excretions = sum(kgN_excretions, na.rm = T),\n    kgP_excretions = sum(kgP_excretions, na.rm = T),\n    kgK_excretions = sum(kgK_excretions, na.rm = T)\n    )\n\n#then we remove arrondissements from the main file\npopulation_communes &lt;- population_communes %&gt;% \n  filter(!code_commune %in% c(\n    \"75101\", \"75102\", \"75103\", \"75104\", \"75105\", \"75106\", \"75107\", \"75108\", \"75109\", \"75110\",\n    \"75111\", \"75112\", \"75113\", \"75114\", \"75115\", \"75116\", \"75117\", \"75118\", \"75119\", \"75120\"))\n\n#finally we merge the two files\npopulation_communes &lt;- \n  bind_rows(population_communes, temp)\nrm(temp)\n\n#we remove overseas territories\npopulation_communes &lt;- population_communes %&gt;% \n  filter(!code_department %in% c(\n    \"971\", \"972\", \"973\", \"974\"))\n\n\nofficial_pop &lt;- sum(population_communes$population, na.rm=T)/10^6 # 64.8 Mhab\nofficial_N_excr &lt;- sum(population_communes$kgN_excretions, na.rm=T)/10^6 # 294 ktN\nofficial_P_excr &lt;- sum(population_communes$kgP_excretions, na.rm=T)/10^6 # 28.2 ktP\nofficial_K_excr &lt;- sum(population_communes$kgK_excretions, na.rm=T)/10^6 # 69.8 ktK\n\nN_excrec_per_cap &lt;- official_N_excr/official_pop # 4.54 kgN/cap\nP_excrec_per_cap &lt;- official_P_excr/official_pop # 0.44 kgP/cap\nK_excrec_per_cap &lt;- official_K_excr/official_pop # 1.08 kgK/cap\n\n\nI add communes spatial polygons from Géoservices Admin Express shapefile data (link) to INSEE communes data.\n\n\nCode\n#all communes in sf_communes are in population_communes (unpaired is empty)\nunpaired &lt;- anti_join(sf_communes, population_communes, by=\"code_commune\")\n\n#check communes in population_communes not present in sf_communes: 3244 communes concerned, but they all report 0 inhabitants, so no consequence\nunpaired &lt;- anti_join(population_communes, sf_communes, by=\"code_commune\")\nnrow(unpaired) #3244 communes\nsum(unpaired$population, na.rm=T) #0 hab\nrm(unpaired)\n\n#so we chose to perform an inner join (to not keep these communes with 0 inhabitants)\npopulation_communes &lt;- inner_join(\n  population_communes, \n  sf_communes %&gt;% \n    #remove columns already in population_communes\n    select(-c(name_commune, code_department, code_region)), \n  by=\"code_commune\"\n  ) \n\n# uncomment to check coherence between the 2 datasets communes population\n# ggplot(population_communes) +\n#   geom_point(aes(population_sf, population)) +\n#   scale_x_log10() + scale_y_log10()\n\n# INSEE and shapefile population data are very similar\nsum(population_communes$population, na.rm=T)/10^6 #64.8 in the INSEE data by age\nsum(sf_communes$population_sf, na.rm=T)/10^6 #64.6 in the shapefile \n\n#we only keep the official INSEE popultion data\npopulation_communes &lt;- population_communes %&gt;% select(-population_sf)\n\n\n#compute communes area based on polygon\npopulation_communes &lt;- population_communes %&gt;%\n  mutate(\n    area_m2 = st_area(geometry),\n    area_commune_ha = as.numeric(area_m2/10000),\n    area_commune_km2 = as.numeric(area_commune_ha/100)\n    ) %&gt;%\n  select(-area_m2)\n\n\n\n\nPopulation at the 1 km2 resolution (source of the dataset from INSEE).\nOnce again I adapt the population data by age to convert it to nutrient excretions.\n\n\nCode\npopulation_1km2 &lt;- st_read(\"source/population/population_density_1km/Filosofi2015_carreaux_1000m_shp/Filosofi2015_carreaux_1000m_metropole.shp\")\n#CRS = RGF93 v1 / Lambert-93 (EPSG, 2154). OK\n\n#transform squares to points\npopulation_1km2 &lt;- population_1km2 %&gt;%\n  mutate(geometry = st_centroid(geometry)) \n\n\n#compute excretions no considering ages, just mean excretion from previous study\npopulation_1km2_no_ages &lt;- population_1km2 %&gt;%\n  select(\n    population = Ind\n    ) %&gt;%\n  mutate(\n    kgN_excretions = population*N_excrec_per_cap,\n    kgP_excretions = population*P_excrec_per_cap,\n    kgK_excretions = population*K_excrec_per_cap\n  )\n\n\n#excretion based on ages categories\npopulation_1km2_ages &lt;- population_1km2 %&gt;%\n  select(\n    Ind_0_3, Ind_4_5, Ind_6_10, Ind_11_17, Ind_18_24, Ind_25_39, Ind_40_54, Ind_55_64, Ind_65_79, Ind_80p, Ind_inc\n    ) %&gt;%\n  mutate(\n    #N by age\n    N_inca_0_1 = 0.91*Ind_0_3/4,\n    N_inca_1_3 = 2.55*Ind_0_3*3/4,\n    N_inca_4_6 = 3.26*Ind_4_5,\n    N_inca_7_10 = 3.94*Ind_6_10,\n    N_inca_11_14 = 4.38*Ind_11_17*4/7,\n    N_inca_15_17 = 4.49*Ind_11_17*3/7,\n    N_inca_18_44 = 4.71*(Ind_18_24 + Ind_25_39),\n    N_inca_45_64 = 4.89*(Ind_40_54 + Ind_55_64),\n    N_inca_65_79 = 4.56*(Ind_65_79 + Ind_80p),\n    N_inca_unknown = Ind_inc*N_excrec_per_cap,\n    \n    #P by age\n    P_inca_0_1 = 0.137*Ind_0_3/4,\n    P_inca_1_3 = 0.3*Ind_0_3*3/4,\n    P_inca_4_6 = 0.354*Ind_4_5,\n    P_inca_7_10 = 0.409*Ind_6_10,\n    P_inca_11_14 = 0.442*Ind_11_17*4/7,\n    P_inca_15_17 = 0.438*Ind_11_17*3/7,\n    P_inca_18_44 = 0.453*(Ind_18_24 + Ind_25_39),\n    P_inca_45_64 = 0.456*(Ind_40_54 + Ind_55_64),\n    P_inca_65_79 = 0.423*(Ind_65_79 + Ind_80p),\n    P_inca_unknown = Ind_inc*P_excrec_per_cap,\n    \n    #K by age\n    K_inca_0_1 = 0.297*Ind_0_3/4,\n    K_inca_1_3 = 0.653*Ind_0_3*3/4,\n    K_inca_4_6 = 0.796*Ind_4_5,\n    K_inca_7_10 = 0.905*Ind_6_10,\n    K_inca_11_14 = 0.978*Ind_11_17*4/7,\n    K_inca_15_17 = 0.971*Ind_11_17*3/7,\n    K_inca_18_44 = 1.08*(Ind_18_24 + Ind_25_39),\n    K_inca_45_64 = 1.19*(Ind_40_54 + Ind_55_64),\n    K_inca_65_79 = 1.14*(Ind_65_79 + Ind_80p),\n    K_inca_unknown = Ind_inc*K_excrec_per_cap,\n    \n    \n    #total N, P, K and population\n    #N\n    kgN_excretions = N_inca_0_1 + N_inca_1_3 + N_inca_4_6 + N_inca_7_10 + N_inca_11_14 + N_inca_15_17 + N_inca_18_44 + N_inca_45_64 + N_inca_65_79 + N_inca_unknown ,\n    #P\n    kgP_excretions = P_inca_0_1 + P_inca_1_3 + P_inca_4_6 + P_inca_7_10 + P_inca_11_14 + P_inca_15_17 + P_inca_18_44 + P_inca_45_64 + P_inca_65_79 + P_inca_unknown ,\n    #K\n    kgK_excretions = K_inca_0_1 + K_inca_1_3 + K_inca_4_6 + K_inca_7_10 + K_inca_11_14 + K_inca_15_17 + K_inca_18_44 + K_inca_45_64 + K_inca_65_79 + K_inca_unknown ,\n    #population\n    population = Ind_0_3+ Ind_4_5 + Ind_6_10 + Ind_11_17 + Ind_18_24 + Ind_25_39 + Ind_40_54 + Ind_55_64 + Ind_65_79 + Ind_80p + Ind_inc\n    ) %&gt;%\n  select(\n    kgN_excretions, kgP_excretions, kgK_excretions, population\n  )\n\n\nThere are small discrepancies with the commune datasets regarding the resulting excretions (see the Comparison tab). This is mostly because the 1 km2 dataset reports a slightly smaller population. The different age distribution in the 1 km2 compared to the communes dataset almost does not influence the result (code chunk below).\n\n\nCode\n# detailed ages results\nsum(population_1km2_ages$population)/10^6 # 62.9 Mhab\nsum(population_1km2_ages$kgN_excretions)/10^6 # 283.5 ktN (instead of 297)\nsum(population_1km2_ages$kgP_excretions)/10^6 # 27.2 ktP (instead of 28.4)\nsum(population_1km2_ages$kgK_excretions)/10^6 # 67.6 ktK (instead of 70)\nsum(population_1km2_ages$kgN_excretions)/sum(population_1km2_ages$population) # gives mean 4.5 kgN/cap.year\nsum(population_1km2_ages$kgP_excretions)/sum(population_1km2_ages$population) # gives mean 0.43 kgP/cap.year\nsum(population_1km2_ages$kgK_excretions)/sum(population_1km2_ages$population) # gives mean 1.07 kgK/cap.year\n\n# no ages results\nsum(population_1km2_no_ages$population)/10^6  # 62.9 Mhab\nsum(population_1km2_no_ages$kgN_excretions)/10^6 #286 ktN (based on hypothesis 4.6 kgN/cap/year)\nsum(population_1km2_no_ages$kgP_excretions)/10^6 #27.4 ktP (based on hypothesis 0.44 kgN/cap/year)\nsum(population_1km2_no_ages$kgK_excretions)/10^6 #67.7 ktK (based on hypothesis 1.08 kgN/cap/year)\n\npopulation_1km2 &lt;- population_1km2_ages\nrm(population_1km2_ages, population_1km2_no_ages)\n\n\n\n\n\n\nCode\ndata.table::setDT(population_1km2) #data.table for fast summarizing on large data\ndata.table::setDT(population_communes) \n\n#summarize population and excretions at national scale, for communes dataset\nsummary_communes &lt;- population_communes %&gt;%\n  select(population, kgN_excretions, kgP_excretions, kgK_excretions) %&gt;%\n  summarise(\n    `Population\\n(million habs)` = round(sum(population, na.rm=T)/10^6, 1),\n    `N excretions\\n(ktN)` = round(sum(kgN_excretions, na.rm=T)/10^6, 0),\n    `P excretions\\n(ktP)` = round(sum(kgP_excretions, na.rm=T)/10^6, 1),\n    `K excretions\\n(ktK)` = round(sum(kgK_excretions, na.rm=T)/10^6, 1)\n    ) %&gt;%\n  mutate(\n    source = \"communes dataset\"\n  )\n\n#summarize population and excretions at national scale, for 1 km2 dataset\nsummary_1km2 &lt;- population_1km2 %&gt;%\n  select(population, kgN_excretions, kgP_excretions, kgK_excretions) %&gt;%\n  summarise(\n    `Population\\n(million habs)` = round(sum(population, na.rm=T)/10^6, 1),\n    `N excretions\\n(ktN)` = round(sum(kgN_excretions, na.rm=T)/10^6, 0),\n    `P excretions\\n(ktP)` = round(sum(kgP_excretions, na.rm=T)/10^6, 1),\n    `K excretions\\n(ktK)` = round(sum(kgK_excretions, na.rm=T)/10^6, 1)\n    ) %&gt;%\n  mutate(\n    source = \"population 1km2 dataset\"\n  )\n\n#create datasets of the 2 summaries, for graph\ndf_comparison &lt;- \n  bind_rows(summary_communes, summary_1km2) %&gt;%\n  gather(variable, value, -source)\ntemp &lt;- df_comparison %&gt;% spread(source, value) %&gt;%\n  mutate(\n    percentage_difference = round((`population 1km2 dataset` - `communes dataset`)/`communes dataset`*100)\n  )\n\n#plot graph of comparisons\nggplot(df_comparison) +\n  geom_col(\n    aes(source, value, fill=source), \n    position = \"dodge\", alpha=.7, width = 0.5\n    ) +\n  geom_label(\n    aes(source, value, label=value), \n    position = \"dodge\"\n    ) +\n  geom_label(\n    data = temp,\n    aes(1.5, 0, label=paste0(\"difference:\\n\", percentage_difference, \"%\")), \n    vjust=0\n    ) +\n  facet_wrap(\n    vars(variable), scales=\"free_y\"\n    ) +\n  theme(\n    axis.text.x = element_blank(),\n    legend.position = \"top\"\n    ) +\n  labs(\n    x=\"\", y=\"\", fill=\"\",\n    title = \"Difference between the 2 datasets\",\n    subtitle = \"due to population and age categories differences\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n#remove temporary files used for graph\nrm(temp, df_comparison, summary_communes, summary_1km2)\n\n\n\n\n\n\nCode\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\npopulation_1km2 &lt;- st_as_sf(population_1km2)\n\n#prepare raster\npopulation_4km2 &lt;- f_prepare_raster(\n  population_1km2 %&gt;% mutate(kgNorg = 0, area_ha = 100), #have to fill Norg and area variables for function f_prepare_raster\n  area_ha, kgN_excretions, kgP_excretions, kgK_excretions, kgNorg,\n  resolution_meters, sf_france\n  )\n#rm(population_1km2)\n\n\njoin raster data with communes description = 1 km2\n\n\nCode\npopulation_1km2 &lt;- st_as_sf(population_1km2, coords = c(\"x\", \"y\"), crs = CRS_RGF93_Lambert93) %&gt;%\n  #remove pixels with no population\n  filter(is.na(population)==F)\n\n#to save coordinates in 2 columns later (points geometry dropped in the following join)\npopulation_1km2 &lt;- population_1km2 %&gt;%\n  mutate(\n    y = st_coordinates(geometry)[, \"Y\"],\n    x = st_coordinates(geometry)[, \"X\"]\n  )\n\n#attribute each point of population_1km2 to a polygon commune of sf_communes\n#st_join(population_1km2, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n\n#first, dropping the points not within a commune polygon, to see the % of losses\njoin_dropping_unattributed_points &lt;- st_join(sf_communes, population_1km2, join = st_intersects)\n\n# 0.4% of pixels not attributed to a commune\n(nrow(population_1km2)-nrow(join_dropping_unattributed_points))/nrow(population_1km2)*100 \n\n#correspond to 0.4% of the original population in the population_1km2 file\n(sum(population_1km2$population, na.rm=T)-sum(join_dropping_unattributed_points$population, na.rm=T))/sum(population_1km2$population, na.rm=T)*100\n\n#now real join, keeping the pixels with unattributed communes\npopulation_1km2 &lt;- st_join(population_1km2, sf_communes, join = st_intersects)\nrm(join_dropping_unattributed_points)\n\n#add old regions with spatial join\npopulation_1km2 &lt;- st_join(population_1km2, sf_old_regions %&gt;% select(code_old_region = code_insee), join = st_intersects)\n\n#remove data communes present in sf not attributed to pixels (based on in existent lat and long)\npopulation_1km2 &lt;- population_1km2 %&gt;% filter(is.na(x)==F & is.na(y)==F)\n\n#the join removed pixels points and added communes polygons: recompute points and remove polygons\npopulation_1km2 &lt;- population_1km2 %&gt;% st_drop_geometry()\n# population_1km2 &lt;- st_as_sf(population_1km2, coords = c(\"lon_RGF93_LAMB_93\", \"lat_RGF93_LAMB_93\"), crs = CRS_RGF93_Lambert93) \n# population_1km2 &lt;- population_1km2 %&gt;%\n#   mutate(\n#     lat_RGF93_LAMB_93 = st_coordinates(geometry)[, \"Y\"],\n#     lon_RGF93_LAMB_93 := st_coordinates(geometry)[, \"X\"]\n#   )\n\n#add region and old region names\ntemp &lt;- read_csv(\"source/regions_data/regions_keys.csv\", col_types = cols(\"c\", \"c\", \"c\", \"c\"))\n#add region name based on code_region \npopulation_1km2 &lt;- population_1km2 %&gt;% left_join(temp %&gt;% select(code_region, name_region) %&gt;% distinct(), by=\"code_region\")\n#add old region name based on code_old_region\npopulation_1km2 &lt;- population_1km2 %&gt;% left_join(temp %&gt;% select(code_old_region, name_old_region), by=\"code_old_region\")\nrm(temp)\n\n\njoin raster data with communes description = 4 km2\n\n\nCode\npopulation_4km2 &lt;- st_as_sf(population_4km2, coords = c(\"x\", \"y\"), crs = CRS_RGF93_Lambert93) %&gt;%\n  #remove pixels with no population\n  filter(is.na(population)==F)\n\n#to save coordinates in 2 columns later (points geometry dropped in the following join)\npopulation_4km2 &lt;- population_4km2 %&gt;%\n  mutate(\n    y = st_coordinates(geometry)[, \"Y\"],\n    x = st_coordinates(geometry)[, \"X\"]\n  )\n\n#attribute each point of population_1km2 to a polygon commune of sf_communes\n#st_join(population_1km2, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n\n#first, dropping the points not within a commune polygon, to see the % of losses\njoin_dropping_unattributed_points &lt;- st_join(sf_communes, population_4km2, join = st_intersects)\n\n# 0.4% of pixels not attributed to a commune\n(nrow(population_4km2)-nrow(join_dropping_unattributed_points))/nrow(population_4km2)*100 \n\n#correspond to 1% of the original population in the population_4km2 file\n(sum(population_4km2$population, na.rm=T)-sum(join_dropping_unattributed_points$population, na.rm=T))/sum(population_4km2$population, na.rm=T)*100\n\n#now real join, keeping the pixels with unattributed communes\npopulation_4km2 &lt;- st_join(population_4km2, sf_communes, join = st_intersects)\nrm(join_dropping_unattributed_points)\n\n#add old regions with spatial join\npopulation_4km2 &lt;- st_join(population_4km2, sf_old_regions %&gt;% select(code_old_region = code_insee), join = st_intersects)\n\n#remove data communes present in sf not attributed to pixels (based on in existent lat and long)\npopulation_4km2 &lt;- population_4km2 %&gt;% filter(is.na(x)==F & is.na(y)==F)\n\n#the join removed pixels points and added communes polygons: recompute points and remove polygons\npopulation_4km2 &lt;- population_4km2 %&gt;% st_drop_geometry()\n# population_4km2 &lt;- st_as_sf(population_4km2, coords = c(\"lon_RGF93_LAMB_93\", \"lat_RGF93_LAMB_93\"), crs = CRS_RGF93_Lambert93) \n# population_4km2 &lt;- population_4km2 %&gt;%\n#   mutate(\n#     lat_RGF93_LAMB_93 = st_coordinates(geometry)[, \"Y\"],\n#     lon_RGF93_LAMB_93 := st_coordinates(geometry)[, \"X\"]\n#   )\n\n#add region and old region names\ntemp &lt;- read_csv(\"source/regions_data/regions_keys.csv\", col_types = cols(\"c\", \"c\", \"c\", \"c\"))\n#add region name based on code_region \npopulation_4km2 &lt;- population_4km2 %&gt;% left_join(temp %&gt;% select(code_region, name_region) %&gt;% distinct(), by=\"code_region\")\n#add old region name based on code_old_region\npopulation_4km2 &lt;- population_4km2 %&gt;% left_join(temp %&gt;% select(code_old_region, name_old_region), by=\"code_old_region\")\nrm(temp)\n\n\n\n\nCode\n#transform for variable per our resolution (here 4 km2) to variable per km2\npopulation_4km2 &lt;- population_4km2 %&gt;%\n  mutate(\n  #population\n  pop_per_km2 = population/km2_resolution,\n  pop_commune_per_ha = pop_per_km2/100,\n    ) %&gt;%\n  filter(\n    is.na(pop_per_km2)==F\n    )\n\n\n\n\nCode\n#transform for variable per our resolution (here 1 km2) to variable per km2\npopulation_1km2 &lt;- population_1km2 %&gt;%\n  mutate(\n  #population\n  pop_per_km2 = population,\n  pop_commune_per_ha = pop_per_km2/100,\n    ) %&gt;%\n  filter(\n    is.na(pop_per_km2)==F\n    )\n\n\n\n\nCode\npopulation_communes &lt;- population_communes %&gt;%\n  mutate(\n    #population\n    pop_commune_per_km2 = population/area_commune_km2,\n    pop_commune_per_ha = pop_commune_per_km2/100,\n    \n    #tN/km2 and kgN/ha\n    kgN_excretions_per_ha = kgN_excretions/area_commune_ha,\n    tN_excretions_per_km2 = kgN_excretions_per_ha/1000*100,\n    \n    #tP/km2 and kgP/ha\n    kgP_excretions_per_ha = kgP_excretions/area_commune_ha,\n    tP_excretions_per_km2 = kgP_excretions_per_ha/1000*100,\n    \n    #tK/km2 and kgK/ha\n    kgK_excretions_per_ha = kgK_excretions/area_commune_ha,\n    tK_excretions_per_km2 = kgK_excretions_per_ha/1000*100\n    \n    ) %&gt;%\n  filter(\n    is.na(pop_commune_per_km2)==F\n    )\npopulation_communes &lt;- st_as_sf(population_communes)\n\n\nsave data\n\n\nCode\n# COMMUNES DATASET\n\n#save a file without commune polygon but just its x and y coordinates, to simplify\ntemp &lt;- population_communes\ntemp$geometry &lt;- st_centroid(temp$geometry)\n\n#add old regions with a spatial join on communes coordinates\ntemp &lt;- st_join(temp, sf_old_regions %&gt;% select(code_old_region = code_insee), join = st_intersects)\n\n#add region and old region names\ntemp_keys_regions &lt;- read_csv(\"source/regions_data/regions_keys.csv\", col_types = cols(\"c\", \"c\", \"c\", \"c\"))\n#add region name based on code_region \ntemp &lt;- temp %&gt;% left_join(temp_keys_regions %&gt;% select(code_region, name_region) %&gt;% distinct(), by=\"code_region\")\n#add old region name based on code_old_region\ntemp &lt;- temp %&gt;% left_join(temp_keys_regions %&gt;% select(code_old_region, name_old_region), by=\"code_old_region\")\nrm(temp_keys_regions)\n\n#explicit name of projection and coordinate system for x and y\ntemp &lt;- temp %&gt;%\n  mutate(\n    lat_RGF93_LAMB_93_excr = st_coordinates(geometry)[, \"Y\"],\n    lon_RGF93_LAMB_93_excr := st_coordinates(geometry)[, \"X\"]\n  ) %&gt;%\n  #explicitly say it concerns excretions\n  rename(\n    code_region_excr = code_region,\n    name_region_excr = name_region,\n    code_department_excr = code_department,\n    code_commune_excr = code_commune,\n    name_commune_excr = name_commune,\n    code_old_region_excr = code_old_region,\n    name_old_region_excr = name_old_region,\n  ) %&gt;%\n  st_drop_geometry()\n\nf_save_csv_files(\n  temp, \"output/excretions/\",\n  \"excretions_by_communes.csv\"\n)\n\n\n# RASTER 4 KM2 DATASET\n\ntemp &lt;- population_4km2 %&gt;%\n  rename(\n    lat_RGF93_LAMB_93_excr = y,\n    lon_RGF93_LAMB_93_excr = x,\n    cell_ID = ID\n    ) %&gt;%\n  #explicitly say it concerns excretions\n  rename(\n    code_region_excr = code_region,\n    name_region_excr = name_region,\n    code_department_excr = code_department,\n    code_commune_excr = code_commune,\n    name_commune_excr = name_commune,\n    code_old_region_excr = code_old_region,\n    name_old_region_excr = name_old_region,\n  )\n\nf_save_csv_files(\n  temp, \"output/excretions/\",\n  \"excretions_by_4km2.csv\"\n)\nf_save_parquet_files(\n  temp, \"output/excretions/\",\n  \"excretions_by_4km2.parquet\"\n)\n#sum(temp$population)\n\n\n\n# RASTER 1 KM2 DATASET\n\ntemp &lt;- population_1km2 %&gt;%\n  #create a unique ID\n  mutate(ID = row_number()) %&gt;%\n  rename(\n    lat_RGF93_LAMB_93_excr = y,\n    lon_RGF93_LAMB_93_excr = x,\n    cell_ID = ID\n    ) %&gt;%\n  #explicitly say it concerns excretions\n  rename(\n    code_region_excr = code_region,\n    name_region_excr = name_region,\n    code_department_excr = code_department,\n    code_commune_excr = code_commune,\n    name_commune_excr = name_commune,\n    code_old_region_excr = code_old_region,\n    name_old_region_excr = name_old_region,\n  )\n\nf_save_csv_files(\n  temp, \"output/excretions/\",\n  \"excretions_by_1km2.csv\"\n)\nf_save_parquet_files(\n  temp, \"output/excretions/\",\n  \"excretions_by_1km2.parquet\"\n)\n#sum(temp$population)\n\n #remove temporary old region file\nrm(sf_old_regions)\n\n\nsimplify communes polygons for faster plot\n\n\nCode\npopulation_communes &lt;- st_simplify(population_communes, 100, preserveTopology = T)\n\n\n\n\n\n\n\nMaps\n\n\nCode\n#functions_to_prepare_data_for_maps\n\n#function to see distribution \nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n#function for map from communes\nf_graph_communes &lt;- function(title, legend){\n  ggplot(population_communes %&gt;% filter(is.na(category)==F)) +\n    geom_sf(data = sf_france, fill=NA) +\n    geom_sf(\n      aes(fill=category), lwd = 0\n      ) +\n    labs(\n      title = title,\n      fill=legend,\n      caption=\"\\n\\n\"\n      ) +\n    coord_sf(datum = NA) #remove x and y axis notations\n}\n\n\n\npopulationN excretedP excretedK excretedResolution comparison\n\n\n\n\nCode\nbreaks &lt;- c(0, 10, 100, 1000, 10000, 100000000)\nlabels &lt;- c(\"0 - 10\", \"10 - 100\", \"100 - 1 000\", \"1 000 - 10 000\", \"&gt; 10 000\")\n\npopulation_4km2 &lt;- f_categorize_densities(\n  population_4km2, \"pop_per_km2\", breaks, labels)\npopulation_communes &lt;- f_categorize_densities(\n  population_communes, \"pop_commune_per_km2\", breaks, labels)\n\n\n\n4 km2 datacommunes datadistribution\n\n\n\n\nCode\nf_grap_map_raster(\n  population_4km2, \n  category, \"population per km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Population density\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_communes(\"Population density\", \"population per km2\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(population_4km2, pop_per_km2, \"population\") +\n  scale_x_log10(labels = scales::label_number(drop0trailing = TRUE)) +\n  labs(x=\"mean population density (hab/km2)\\non the 4 km2 pixel\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nbreaks &lt;- c(0, 1, 3, 5, 10, 100000)\nlabels &lt;- c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt; 10\")\n\npopulation_4km2 &lt;- f_categorize_densities(\n  population_4km2, \"tNmin_per_km2\", breaks, labels)\npopulation_communes &lt;- f_categorize_densities(\n  population_communes, \"tN_excretions_per_km2\", breaks, labels)\n\n\n\n4 km2 datadistribution\n\n\n\n\nCode\ngg &lt;- f_grap_map_raster(\n  population_4km2, \n  category, \"tons of\\nN excreted\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"N excretions in France (~ 280 ktN)\"\n    )\ngg\n\n\n\n\n\n\n\n\n\nCode\n#save for manuscript\ngg &lt;- gg + labs(title = \"\", caption=\"\")\nf_save_graph_pdf_png(\n  gg, \n  \"graph/excretions/\", \"map_N_excreted\",\n  1000, 5, 6\n)\n\n#plot at commune scale\n#f_graph_communes(\"N excretions in France(~ 280 ktN)\", \"mean\\nkgN excreted\\nper ha\")\n\n\n\n\nattention ce n’est pas par ha mais par km2 !!\n\n\nCode\nf_graph_distribution(population_4km2, tNmin_per_km2, \"tons of N excreted\") +\n  scale_x_log10(labels = scales::label_number(drop0trailing = TRUE)) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nbreaks &lt;- c(0, .1, .3, .5, 1, 100000)\nlabels &lt;- c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \".5 - 1\", \"&gt; 1\")\n\npopulation_4km2 &lt;- f_categorize_densities(\n  population_4km2, \"tPmin_per_km2\", breaks, labels)\n\npopulation_communes &lt;- f_categorize_densities(\n  population_communes, \"tP_excretions_per_km2\", breaks, labels)\n\n\n\n4 km2 datadistribution\n\n\n\n\nCode\nf_grap_map_raster(\n  population_4km2, \n  category, \"tons of\\nP excreted\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"P excretions in France (~ 28 ktP)\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n# plot at commune scale\n#f_graph_communes(\"P excretions in France(~ 28 ktP)\", \"mean\\nkgP excreted\\nper ha\")\n\n\n\n\nattention ce n’est pas par ha mais par km2 !!\n\n\nCode\nf_graph_distribution(population_4km2, tPmin_per_km2, \"tons of P excreted\") +\n  scale_x_log10(labels = scales::label_number(drop0trailing = TRUE)) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nbreaks &lt;- c(0, .2, .6, 1, 2, 100000)\nlabels &lt;- c(\"&lt; 0.2\", \"0.2 - 0.6\", \"0.6 - 1\", \"1 - 2\", \"&gt; 2\")\n\npopulation_4km2 &lt;- f_categorize_densities(\n  population_4km2, \"tKmin_per_km2\", breaks, labels)\npopulation_communes &lt;- f_categorize_densities(\n  population_communes, \"tK_excretions_per_km2\", breaks, labels)\n\n\n\n4 km2 datadistribution\n\n\n\n\nCode\nf_grap_map_raster(\n  population_4km2, \n  category, \"tons of\\nK excreted\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"K excretions in France (~ 70 ktK)\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n#plot at commune scale\n#f_graph_communes(\"K excretions in France(~ 70 ktK)\", \"mean\\nkgK excreted\\nper ha\")\n\n\n\n\n\n\nCode\nf_graph_distribution(population_4km2, tKmin_per_km2, \"tons of K excreted\") +\n  scale_x_log10(labels = scales::label_number(drop0trailing = TRUE)) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nggplot(population_communes) + \n  geom_histogram(\n    aes(area_commune_km2)\n    ) +\n  geom_vline(\n    xintercept = 4, linetype = \"dashed\"\n    ) +\n  scale_x_log10(\n    labels = scales::label_number(drop0trailing = TRUE), \n    limits = c(0.5, 300)\n    ) +\n  annotate(\n    geom = \"text\", x = 4, y = 2500, hjust = 1, fontface = \"italic\",\n    label = \"raster's pixel \\narea (4 km2) \"\n    ) +\n  labs(\n    title = \"Distribution of communes area\",\n    x = \"commune area (km2)\", y = \"number of communes\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R11_Ile_de_France.html",
    "href": "1_R11_Ile_de_France.html",
    "title": "Île-de-France",
    "section": "",
    "text": "Code\nregion &lt;- \"Île-de-France\"\npath_region &lt;- \"Ile_de_France\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Île-de-France region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R27_Bourgogne_Franche_Comte.html",
    "href": "1_R27_Bourgogne_Franche_Comte.html",
    "title": "Centre-Vale de Loire",
    "section": "",
    "text": "Code\nregion &lt;- \"Bourgogne-Franche-Comté\"\npath_region &lt;- \"Bourgogne_Franche_Comte\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Bourgogne-Franche-Comté region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R32_Hauts_de_France.html",
    "href": "1_R32_Hauts_de_France.html",
    "title": "Hauts-de-France",
    "section": "",
    "text": "Code\nregion &lt;- \"Hauts-de-France\"\npath_region &lt;- \"Hauts_de_France\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Hauts-de-France region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R52_Pays_de_la_Loire.html",
    "href": "1_R52_Pays_de_la_Loire.html",
    "title": "Pays de la Loire",
    "section": "",
    "text": "Code\nregion &lt;- \"Pays de la Loire\"\npath_region &lt;- \"Pays_de_la_Loire\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Pays de la Loire region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R75_Nouvelle_Aquitaine.html",
    "href": "1_R75_Nouvelle_Aquitaine.html",
    "title": "Nouvelle Aquitaine",
    "section": "",
    "text": "Code\nregion &lt;- \"Nouvelle-Aquitaine\"\npath_region &lt;- \"Nouvelle_Aquitaine\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Nouvelle-Aquitaine region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R84_Auvergne_Rhone_Alpes.html",
    "href": "1_R84_Auvergne_Rhone_Alpes.html",
    "title": "Auvergne-Rhône-Alpes",
    "section": "",
    "text": "Code\nregion &lt;- \"Auvergne-Rhône-Alpes\"\npath_region &lt;- \"Auvergne_Rhone_Alpes\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Auvergne-Rhône-Alpes region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "1_R94_Corse.html",
    "href": "1_R94_Corse.html",
    "title": "Corse",
    "section": "",
    "text": "Code\nregion &lt;- \"Corse\"\npath_region &lt;- \"Corse\"\n\n\nFINIR CATCH COVER CROPS\nThis is the pre-processing of the crops fertilization data in Corse region for the years 2015-2020. It uses the RPG data coupled with typical fertilization values. Vineyards and orchards are poorly reported in the RPG database, so we rather use the TOPO database for these 2 crops.\n\n\nCode\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\n# Load the required libraries\nlibrary(sf) #to read shapefiles\nlibrary(data.table) #fast aggregating of large data\nlibrary(arrow) # to write compressed parquet file\nlibrary(plotly) #for interactive plots\nlibrary(cowplot) #for plot_grid in multiple plots\n\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS &lt;- 2154 #Coordinate system : Lambert-93 (2154)\n\n\n\n\nCode\n# load Region keys (name; code)\nregions_keys &lt;- read_csv(\"source/regions_data/regions_keys.csv\")\n# select region\nregions_keys &lt;- regions_keys %&gt;%\n  rename(name_region_parcel = name_region) %&gt;%\n  filter(name_region_parcel ==region)\n\n# load Region areas\n# total area\nregion_area_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_area_ha)\n# agricultural land area\nregion_agri_land_ha &lt;- read_csv(\"source/regions_data/regions_areas.csv\") %&gt;%\n  filter(region_name==region) %&gt;%\n  pull(region_agricultural_land_ha)\n\n\n#load region name and number key\nname &lt;- region\nkey &lt;- unique(regions_keys$code_region[regions_keys$name_region_parcel==region])\nrm(regions_keys)\n\n\n\nLoad and prepare data\n\npre-processRPG dataTOPO dataAdd fertilization on each field\n\n\nEXPLIQUER CE QUE CA FAIT\nFirst we load the data where for each agricultural plots, the cultivated crop and the area are reported (PARCELLES_GRAPHIQUES files).\nWe also load the data with the agricultural crop clusters (ILOTS_ANONYMES files). These agricultural crop clusters gather several contiguous agricultural plots from 1 same farmer. This is used to check that the reported areas are coherent between the 2 files.\nWe assign each agricultural plot to an agricultural crop clusters.\nPREPROCESSING, UNCOMMENT TO REPRODUCE\nWe link each agricultural plot to a region (old French regions). This will be used to assign to each plot a regional fertilization rate.\n\n\nCode\n# #section to load RPG data for years 2015-2020 and gather them, transform parcels polygons to points (to save memory), and attribute each agricultural plot to an old region (smaller regions than current ones, used later to attribute regionalized fertilization values)\n# \n# \n# \n# # load old regions geographical data (used to link each plot to region fertilization practices)\n# sf_old_regions &lt;- st_read(\n#   \"source/maps/old_regions/regions-20140306-5m.shp\",\n#   options = \"ENCODING=WINDOWS-1252\" #encoding to read special French characters\n#   )\n# sf_old_regions &lt;- sf_old_regions %&gt;%\n#   #select only columns of interest, rename in English\n#   select(\n#     code_old_region_parcel = code_insee,\n#     name_old_region_parcel = nom\n#   ) %&gt;%\n#   #load only metropolitan areas, remove overseas territories\n#   filter(\n#     !(name_old_region_parcel %in% c(\"Guadeloupe\", \"Martinique\", \"Guyane\", \"La Réunion\", \"Mayotte\"))\n#   ) %&gt;%\n#   # transform into our coordinate system (Lamber 93)\n#   st_transform(CRS)\n# \n# \n# \n# \n# #loads each file year, and bind the files together after adding a year column\n# final_sf_object &lt;- rbindlist(\n#   lapply(2015:2020, function(year) {\n#     message(\"Key:\", key, \" Name:\", name, \" Year:\", year, \"\\n \\n\")\n# \n#     #path for individual agricultural plots\n#     file_path_fields &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/PARCELLES_GRAPHIQUES.shp\"\n#     )\n# \n#     # path for agricultural crop clusters\n#     file_path_anonym &lt;- paste0(\n#       \"source/RPG_data/RPG_data/R\",\n#       key, \"_\", path_region, \"/\",\n#       \"RPG_2-0__SHP_LAMB93_R\", key, \"_\", year,\n#       \"/RPG/\",\n#       \"1_DONNEES_LIVRAISON_\", year, \"/RPG_2-0_SHP_LAMB93_R\", key, \"-\", year,\n#       \"/ILOTS_ANONYMES.shp\"\n#     )\n# \n#     # load individual agricultural plots and agricultural crop clusters\n#     temp_fields &lt;- st_read(file_path_fields)\n#     temp_anonym &lt;- st_read(file_path_anonym)\n# \n#     #data.table object to be faster\n#     setDT(temp_fields)\n#     setDT(temp_anonym)\n# \n#     # Calculate polygon centroids of fields (data.table syntax)\n#     temp_fields[, centroid := st_centroid(geometry)]\n#     temp_fields[, PARCEL_lat_RGF93_LAMB_93 := st_coordinates(centroid)[, \"Y\"]]\n#     temp_fields[, PARCEL_lon_RGF93_LAMB_93 := st_coordinates(centroid)[, \"X\"]]\n# \n#     #compute plot area to check coherence\n#     temp_fields[, SURF_PARC_computed := round(st_area(geometry)/10000, 2)] #st_area in m2, 1 ha = 10 000 m2\n#     temp_anonym[, SURF_ILOT_computed := round(st_area(geometry)/10000, 2)]\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #back to sf object for subsequent geographical join\n#     temp_fields &lt;- st_sf(temp_fields, crs = CRS)\n#     temp_anonym &lt;- st_sf(temp_anonym, crs = CRS)\n# \n#     #attribute each agricultural parcel to an old region (by geographical join)\n#     temp_fields &lt;- st_join(temp_fields, sf_old_regions, join = st_intersects)\n# \n#     #attribute each each agricultural parcel to the anonym plot it belongs to, by geographical join  (is the field point in the anonym polygon ?)\n#     temp_fields &lt;- st_join(temp_anonym, temp_fields, join = st_intersects, left=TRUE)\n#     #st_join(temp_fields, temp_anonym, join = st_within) would be conceptually more correct, but is way slower\n# \n#     #remove anonym filed after join, to save memory\n#     rm(temp_anonym)\n# \n#     #reset to data.table object to be faster\n#     setDT(temp_fields)\n# \n#     #remove geometry polygon column to save memory\n#     temp_fields &lt;- temp_fields[, !\"geometry\", with = FALSE]\n# \n#     #add year, region code and region name\n#     temp_fields[, Year := year]\n#     temp_fields[, code_region_parcel := key]\n#     temp_fields[, name_region_parcel := name]\n# \n#     #files_list &lt;- c(files_list, list(temp_fields))\n# \n#     message(\"\\n \\n \\n\")\n# \n#     return(temp_fields)\n#     })\n# )\n# \n# #transform surface to numerics\n# final_sf_object[, SURF_PARC_computed := as.numeric(SURF_PARC_computed)]\n# final_sf_object[, SURF_ILOT_computed := as.numeric(SURF_ILOT_computed)]\n# \n# #add denomination \"None or not reported\" for catch and cover crops\n# final_sf_object[, CULTURE_D1 := fifelse(is.na(CULTURE_D1), \"None or not reported\", CULTURE_D1)]\n# final_sf_object[, CULTURE_D2 := fifelse(is.na(CULTURE_D2), \"None or not reported\", CULTURE_D2)]\n# \n# #remove anonym plots not linked to any actual agricultural plot\n# anonyms_orphans &lt;- final_sf_object[is.na(ID_PARCEL), .(ID_ILOT, SURF_ILOT_computed, Year, code_region_parcel, name_region_parcel)][, unique(.SD)]\n# final_sf_object &lt;- final_sf_object[!is.na(ID_PARCEL)]\n# \n# \n# \n# # if you want to check that reported plot surface are coherent with the actual polygon surface\n# #ggplot(final_sf_object) + geom_point(aes(SURF_PARC, SURF_PARC_computed))\n# \n# \n# #If you want to check coherence between ILOTs and their attributed PARCELs\n# # temp &lt;- final_sf_object[,\n# #                         .(area_group_of_PARCELS = sum(SURF_PARC_computed, na.rm=T),\n# #                           area_ILOT_of_PARCELS = SURF_ILOT_computed),\n# #                         by = .(Year, ID_ILOT)]\n# #\n# # ggplot(temp) +\n# #   geom_histogram(aes(area_ILOT_of_PARCELS/area_group_of_PARCELS)) +\n# #   scale_x_log10() +\n# #   labs(x=\"ratio between ILOT area and\\nthe sum of PARCELs area attributed to it\")\n# \n# \n# # saves pre-processed regional file in parquet format\n# arrow::write_parquet(final_sf_object, paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n# \n# rm(final_sf_object, sf_old_regions)\n\n\n\n\nI load the pre-processed regional RPG data.\n\n\nCode\n#load pre-processed file\nRPG &lt;- arrow::read_parquet(paste0(\"source/RPG_data/preprocessed_RPG_R\", key, \"_\", path_region, \"_2015_2020.parquet\"))\n\n#renames columns\nsetnames(RPG, old = \"CODE_GROUP\", new = \"CODE_GROUPE_CULTURE\")\nsetnames(RPG, old = \"CODE_CULTU\", new = \"CODE_CULTURE\")\nsetnames(RPG, old = \"ID_PARCEL\", new = \"ID_RPG\")\nsetnames(RPG, old = \"SURF_PARC\", new = \"parcel_area_ha\")\nsetnames(RPG, old = \"PARCEL_lat_RGF93_LAMB_93\", new = \"lat_RGF93_LAMB_93_parcel\")\nsetnames(RPG, old = \"PARCEL_lon_RGF93_LAMB_93\", new = \"lon_RGF93_LAMB_93_parcel\")\n\n\nI add the crops complete and simplified RPG French labels, using the crops RPG key codes. I also add a simplified common English label, and fertilization labels to match each crop to a mean fertilization value, in kg/ha.\n\n\nCode\nkeys_crops_groups_fertilization &lt;- read_csv(\n  \"source/keys_crops/keys_crops_groups_fertilization.csv\")\n\nf_match_labels &lt;- function(main_dataset, keys_dataset, groups_codes, groups_names) {\n  matching_indices &lt;- match(main_dataset[[groups_codes]], keys_dataset[[groups_codes]])\n  \n  main_dataset[[groups_names]] &lt;- keys_dataset[[groups_names]][matching_indices]\n  \n  return(main_dataset)\n}\n\n#add French label RPG corresponding to groups codes CODE_GROUPE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_GROUPE_CULTURE\", \"LIBELLE_GROUPE_CULTURE\"\n)\n#add French label RPG corresponding to detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"LIBELLE_CULTURE\"\n)\n#add our English labels for each crop, based on detailed crops codes CODE_CULTURE\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"our_label\"\n)\n#add the French crop_fertilization_label for each crop, based on detailed crops codes CODE_CULTURE, for future matching with fertilization values reported by surveys\nRPG &lt;- f_match_labels(\n  RPG, keys_crops_groups_fertilization,\n  \"CODE_CULTURE\", \"crop_fertilization_label\"\n)\n\n\n\n\n# keys_crops_groups &lt;- read_csv2(\n#   \"source/keys_crops/orginal_RPG_files/REF_CULTURES_GROUPES_CULTURES_2021.csv\"),\n#   col_types = cols(\n#     CODE_CULTURE = col_factor(),\n#     LIBELLE_CULTURE = col_factor(),\n#     CODE_GROUPE_CULTURE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE = col_factor()\n#     )\n#   )\n\n# \n# #adding the \"not reported\" categroy for catch and cover crops\n# keys_crops_groups &lt;- bind_rows(\n#   keys_crops_groups,\n#   data.frame(\n#     CODE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE = as.factor(\"None or not reported\")\n#     )\n#   )\n\n# keys_catch_cover_groups &lt;- read_csv2(\n#   \"source/keys_crops/keys_catch_crops_groups.csv\",\n#   col_types = cols(\n#     CODE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_CULTURE_DEROBEE = col_factor(),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = col_factor(),\n#     CODE_GROUPE_CULTURE_DEROBEE = col_factor()\n#   )\n#   )\n# #adding the \"not reported\" categroy\n# keys_catch_cover_groups &lt;- bind_rows(\n#   keys_catch_cover_groups,\n#   data.frame(\n#     CODE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     LIBELLE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\"),\n#     CODE_GROUPE_CULTURE_DEROBEE = as.factor(\"None or not reported\")\n#   )\n# )\n\n\n# RPG &lt;- f_match_labels(\n#   RPG, keys_crops_groups,\n#   \"CODE_CULTURE\", \"LIBELLE_CULTURE_DEROBEE_1\"\n# )\n\n\n# #matching codes cover catch 1\n# matching_indices &lt;- match(RPG$CULTURE_D1, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_1 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n# \n# #matching codes cover catch 2\n# matching_indices &lt;- match(RPG$CULTURE_D2, keys_catch_cover_groups$CODE_CULTURE_DEROBEE)\n# RPG$LIBELLE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_CULTURE_DEROBEE[matching_indices]\n# RPG$LIBELLE_GROUPE_CULTURE_DEROBEE_2 &lt;- keys_catch_cover_groups$LIBELLE_GROUPE_CULTURE_DEROBEE[matching_indices]\n\nrm(keys_crops_groups_fertilization)\n\n\nI split the RPG data into 4 parts (explanation in the 2 following tabs).\n\nmajor crops\nvegetables and floral crops\nvineyards\norchards\n\n\n\nCode\n# convert to arrow table, to filter data without creating heavy variables in environment\nRPG &lt;- arrow_table(RPG)\n\n#select only orchards\nRPG_orchards &lt;- RPG %&gt;% filter(our_label == \"Orchards\")\n\n#select only vineyards\nRPG_vineyards &lt;- RPG %&gt;% filter(our_label == \"Vineyards\")\n\n#select only vegetables and floral crops\nRPG_vegetables_floral &lt;- RPG %&gt;% filter(our_label == \"Vegetables or floral crops\")\n\n#creates major crops by removing the other particular crops from main file\nRPG_major_crops &lt;- RPG %&gt;% filter(!(our_label %in% c(\"Orchards\", \"Vineyards\", \"Vegetables or floral crops\")))\n\n\n\n\nVineyars and Orchards reporting is incomplete in the RPG database, so I use the more complete TOPO database (see comparison in the vineyards and orchards tabs in the Fertilization and Area paragraph below). The TOPO data was already pre-processed on the XX page.\n\n\nCode\n#load vineyards and orchards regional data from TOPO database, convert to arrow table, to filter data without creating heavy variables in environment\n\n#vineyards\nTOPO_vineyards &lt;- read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/vineyards.parquet\")\nTOPO_vineyards &lt;- arrow_table(TOPO_vineyards)\nTOPO_vineyards &lt;- TOPO_vineyards %&gt;%\n  filter(name_region_parcel == name)\n\n#orchards\nTOPO_orchards &lt;- arrow::read_parquet(\"output/fertilization/temporary_data/TOPO_vineyards_orchards_data/orchards_without_fertilization.parquet\")\nTOPO_orchards &lt;- arrow_table(TOPO_orchards)\nTOPO_orchards &lt;- TOPO_orchards %&gt;%\n  filter(name_region_parcel == name)\n\n\n\n\n\n\nCode\n#function to load the files reporting fertilization values for the different crops types\nf_load_fertilization_values &lt;- function(columns_to_select, path){\n  \n  dataset &lt;- read_csv(path) %&gt;%\n    select(all_of(columns_to_select))\n  \n  setDT(dataset)\n  \n  return(dataset)\n}\n\ncore_variables_selected &lt;- c(\n  \"crop_fertilization_label\", \n  \"N mineral mean fertilization (kgN/ha)\", \n  \"P mineral mean fertilization (kgP/ha)\", \n  \"K mineral mean fertilization (kgK/ha)\",\n  \"N organic mean fertilization (kgN/ha)\" \n)\n\n\n\n\nCode\n#function that computes fertilization (kg) on each plot, based on its area (ha) and the typical fertilization value (kg/ha) for that particular crop\nf_compute_fertilization &lt;- function(dataset, keys_dataset, keys_variables, area_variable, unit){\n  \n  dataset &lt;- dataset %&gt;% left_join(\n    keys_dataset,\n    by=keys_variables\n    )\n  \n  dataset &lt;- dataset %&gt;%\n    mutate(\n      !!paste0(\"N mineral fertilization (\", unit, \"N)\") := `N mineral mean fertilization (kgN/ha)` * {{ area_variable }},\n      !!paste0(\"P mineral fertilization (\", unit, \"P)\") := `P mineral mean fertilization (kgP/ha)` * {{ area_variable }},\n      !!paste0(\"K mineral fertilization (\", unit, \"K)\") := `K mineral mean fertilization (kgK/ha)` * {{ area_variable }},\n      !!paste0(\"N organic fertilization (\", unit, \"N)\") := `N organic mean fertilization (kgN/ha)` * {{ area_variable }}\n    ) \n  \n  return(dataset)\n}\n\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\nMajor crops and Vegetables and floral crops area is based on the RPG data, considered complete. Major crops fertilization values are based on the French Practical Crop Surveys on major crops, temporary leys and grassland (2017). For vegetables and floral crops, whose fertilization values are based on AND International report.\n\n\nCode\n#     MAJOR CROPS\n\n#load major crops and grasslands fertilization values, by crop x old region\nfertilization_major_crops &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_major_crops_leys_grasslands_by_old_region.csv\"\n  ) %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_major_crops &lt;- f_compute_fertilization(\n  RPG_major_crops, \n  fertilization_major_crops,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_major_crops_regional &lt;- f_regional_synthesis(\n  RPG_major_crops, c(\"Year\", \"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_major_crops)\n\n\n\n#    VEGETABLES AND FLORAL CROPS\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vegetables_floral &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_vegetables_floral.csv\")\n\n#compute fertilization on each field\nRPG_vegetables_floral &lt;- f_compute_fertilization(\n  RPG_vegetables_floral, \n  fertilization_vegetables_floral,\n  c(\"crop_fertilization_label\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vegetables_floral_region &lt;- f_regional_synthesis(\n  RPG_vegetables_floral, \n  c(\"Year\", \"CODE_CULTURE\", \"LIBELLE_CULTURE\", \"crop_fertilization_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vegetables_floral)\n\n\nVineyards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Fertilization are estimated from the French Practical Crop Surveys on vineyards (2019). The computation was already carried out on the TOPO page.\n\n\nCode\n#synthesize vineyards TOPO (area and fertilization)\nTOPO_vineyards_region &lt;- f_regional_synthesis(\n  TOPO_vineyards, \n  c(\"name_region_parcel\")\n  )\n\n#load vegetables and floral crops fertilization, by crop (same value nationwide)\nfertilization_vineyards &lt;- f_load_fertilization_values(\n  c(core_variables_selected, \"name_old_region\"), \n  \"output/fertilization/fertilization_surveys/fertilization_vineyards_by_old_region.csv\") %&gt;%\n  rename(\n    name_old_region_parcel = name_old_region\n  )\n\n#compute fertilization on each field\nRPG_vineyards &lt;- f_compute_fertilization(\n  RPG_vineyards, \n  fertilization_vineyards,\n  c(\"crop_fertilization_label\", \"name_old_region_parcel\"), \n  parcel_area_ha, \"kg\"\n  )\n\n#summarize regional values\nRPG_vineyards_region &lt;- f_regional_synthesis(\n  RPG_vineyards, \n  c(\"Year\", \"our_label\", \"name_region_parcel\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_vineyards)\n\n\nAs for vineyards, orchards reporting in the RPG dataset is incomplete. I use instead the TOPO database. Their fertilization values are based on AND International report.\n\n\nCode\n#load orchards fertilization, by crop (same value nationwide)\nfertilization_orchards &lt;- f_load_fertilization_values(\n  core_variables_selected, \n  \"output/fertilization/fertilization_orchards_by_crop.csv\")\n\n#compute fertilization for each crop type\nRPG_orchards &lt;- f_compute_fertilization(\n  RPG_orchards, \n  fertilization_orchards,\n  c(\"crop_fertilization_label\"),\n  parcel_area_ha, \"kg\"\n)\n\n#summarize regional values\nRPG_orchards_region &lt;- f_regional_synthesis(\n  RPG_orchards, c(\"Year\", \"name_region_parcel\", \"LIBELLE_CULTURE\")\n  )\n\n#remove temporary fertilization key file\nrm(fertilization_orchards)\n\n#mean fertilization in kg/ha (all orchards types gathered, mean over 2015-2020)\nfertilization_orchards_regional_mean &lt;- RPG_orchards_region %&gt;%\n  group_by(name_region_parcel) %&gt;%\n  summarise(\n    `N mineral mean fertilization (kgN/ha)` = round(mean(`N mineral fertilization (ktN)`/`area (Mha)`)),\n    `P mineral mean fertilization (kgP/ha)` = round(mean(`P mineral fertilization (ktP)`/`area (Mha)`)),\n    `K mineral mean fertilization (kgK/ha)` = round(mean(`K mineral fertilization (ktK)`/`area (Mha)`)),\n    `N organic mean fertilization (kgN/ha)` = round(mean(`N organic fertilization (ktN)`/`area (Mha)`))\n    ) \n\n#save our regional mean values\nf_save_csv_files(\n  fertilization_orchards_regional_mean, \n  \"output/fertilization/temporary_data/orchards_regional_mean_fertilization/\",\n  paste0(\"orchards_regional_mean_fertilization_\", path_region, \".csv\")\n  )\n\n\nEXPLIQUER QU ON PREND LA MOYENNE\n\n\nCode\nfertilization_orchards_regional_mean %&gt;%\n  gather(nutrient, value, -name_region_parcel) %&gt;%\n  ggplot() +\n  geom_col(aes(nutrient, value, fill=nutrient)) +\n  geom_label(aes(nutrient, value, label=value)) +\n  theme(\n    axis.text.x = element_blank()\n  ) +\n  labs(\n    x=\"\", y=\"kg nutrient per ha\", fill=\"\"\n  ) +\n  facet_wrap(vars(name_region_parcel))\n\n\n\n\n\n\n\n\n\n\n\nCode\nTOPO_orchards &lt;- f_compute_fertilization(\n  TOPO_orchards, \n  fertilization_orchards_regional_mean,\n  c(\"name_region_parcel\"),\n  parcel_area_ha, \"kg\"\n)\n\n#synthesize orchards TOPO (area and fertilization)\nTOPO_orchards_region &lt;- f_regional_synthesis(\n  TOPO_orchards, c(\"name_region_parcel\", \"our_label\")\n  )\n\n#remove temporary fertilization file\nrm(fertilization_orchards_regional_mean)\n\n\n\n\n\n\n\nFertilization and Area\n\nmajor cropsvegetables / floralvineyardsorchardscover crops\n\n\n\n\nCode\nf_graph_regional_major_crops &lt;- function(dataset, y_variable){\n  gg &lt;- ggplot(dataset) +\n    geom_area(\n      aes(Year, {{ y_variable }}, fill=our_label)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(vars(name_region_parcel))\n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_major_crops(RPG_major_crops_regional, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(dataset, variable){\n  \n  gg &lt;- ggplot(RPG_vegetables_floral_region) +\n    geom_area(aes(Year, {{ variable }}, fill=LIBELLE_CULTURE)) +\n    labs(x=\"\")\n  \n  return(ggplotly(gg))\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(RPG_vegetables_floral_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }})\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n}\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_vineyards(RPG_vineyards_region, TOPO_vineyards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards &lt;- function(dataset_RPG, dataset_TOPO, y_variable){\n  ggplot(dataset_RPG) +\n    geom_area(\n      aes(Year, {{ y_variable }},  fill=LIBELLE_CULTURE)\n      ) +\n    labs(\n      x=\"\"\n      ) +\n    facet_wrap(\n      vars(name_region_parcel)\n    ) +\n    geom_hline(\n      yintercept = dataset_TOPO %&gt;% pull({{ y_variable }}),\n      linetype = \"dashed\"\n    ) +\n    labs(\n      subtitle = \"line: based on TOPO area\\narea: based on RPG data\"\n    )\n  }\n\n\n\nN mineralP mineralK mineralN organicArea\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `N organic fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph_regional_orchards(RPG_orchards_region, TOPO_orchards_region, `area (Mha)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\n\n\n\nSynthesis fertilization and area\nRégler ID, je pense tous les appeler ID mais rajouter variable disant si la base est RPG ou TOPO\n\n\nCode\nrm(\n  RPG_vineyards, RPG_orchards,\n  RPG_major_crops_regional, RPG_vegetables_floral_region, RPG_vineyards_region, RPG_orchards_region,\n  TOPO_orchards_region, TOPO_vineyards_region\n)\n\ncolumns_to_select &lt;- c(\n  \"code_region_parcel\",\n  \"name_region_parcel\",\n  \"code_old_region_parcel\",\n  \"name_old_region_parcel\",\n  \"our_label\", \n  \"parcel_area_ha\",\n  \n  \"N mineral fertilization (kgN)\",\n  \"P mineral fertilization (kgP)\",\n  \"K mineral fertilization (kgK)\",\n  \"N organic fertilization (kgN)\",\n  \n  \"crop_fertilization_label\",\n  \"lat_RGF93_LAMB_93_parcel\",\n  \"lon_RGF93_LAMB_93_parcel\",\n  \n  \"CODE_CULTURE\"\n  #ID_RPG\n  )\n\n# For the TOPO-based files (vineyards and orchards) we are permanent crops with no attributed year, we artificially add th years 2015-2020 for coherence with the RPG file.\nadd_years_to_TOPO_files &lt;- function(arrow_query_file, years_vector, vector_columns_to_select, code_crop){\n  \n  data_collected &lt;- arrow_query_file %&gt;% select(all_of(vector_columns_to_select)) %&gt;% collect()\n  \n  data_table_file &lt;- setDT(data_collected)\n  \n  # Create a list of data.tables for each year\n  list_of_data_tables &lt;- lapply(years_vector, function(year) {\n    dt_copy &lt;- copy(data_table_file)\n    dt_copy[, Year := year]\n    return(dt_copy)\n  })\n  \n  # Combine the list of data.tables into one data.table\n  final_dt &lt;- rbindlist(list_of_data_tables)\n  \n  return(final_dt)\n}\n\n\nTOPO_orchards &lt;- add_years_to_TOPO_files(TOPO_orchards, 2015:2020, columns_to_select, \"VRG\") \nTOPO_vineyards &lt;- add_years_to_TOPO_files(TOPO_vineyards, 2015:2020, columns_to_select, \"VRC\") \n\ncolumns_to_select &lt;- c(columns_to_select, \"Year\")\nfull_data &lt;- bind_rows(\n  RPG_major_crops %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  RPG_vegetables_floral %&gt;% select(all_of(columns_to_select)) %&gt;% collect(),\n  TOPO_orchards,\n  TOPO_vineyards\n)\n\nf_save_parquet_files(\n  full_data,\n  \"output/full_data/regional/\",\n  paste0(\"R\", key, \"_\", path_region, \"_2015_2020.parquet\")\n  )\n\nrm(TOPO_orchards, TOPO_vineyards, RPG_major_crops, RPG_vegetables_floral, columns_to_select)\n\n\n\n\nCode\ncsv_name &lt;- paste0(\"R\", key, \"_\", path_region, \"_2015_2020.csv\")\n\n#by crops\nfull_data_regional_crops &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\", \"our_label\")\n  )\nf_save_csv_files(\n  full_data_regional_crops, \"output/regional_synthesis/by_crops\",\n  csv_name\n)\n\n#total\nfull_data_regional &lt;- f_regional_synthesis(\n  full_data, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")\n  )\nf_save_csv_files(\n  full_data_regional, \"output/regional_synthesis\",\n  csv_name\n)\n\n\nahouter UNIFA\n\n\nCode\ngg &lt;- ggplot(full_data_regional_crops) +\n  geom_area(\n    aes(\n      Year, `N mineral fertilization (ktN)`, \n      fill=our_label\n      )\n    ) +\n  labs(fill=\"\", x=\"\")\n\nggplotly(gg)\n\n\n\n\n\n\n\n\nMaps and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\nsf_regions &lt;- sf_regions %&gt;% filter(INSEE_REG == key)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\nf_graph_distribution &lt;- function(dataset, variable, nutrient){\n  ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}),\n      alpha=.7, bins = 100\n      ) +\n    labs(\n      x = paste0(\"mean \", nutrient,\" per ha\\non the \", km2_resolution, \" km2 (\", ha_resolution, \" ha) pixels\")\n      )\n}\n\n\n\n\nCode\n#selects columns for interest for year 2019\nfull_data &lt;- full_data %&gt;% \n  filter(Year==2019) %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\nfull_data &lt;- st_as_sf(full_data, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  full_data, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_regions\n  )\n\n\nATTENTION A LA LEGENDE X DES GRAPHIQUES DISTRIBUTION\n\nN minP minK minN orgAreaResolution consistency\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNmin_per_km2, \"tons of N mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tPmin_per_km2, \"tons of P mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"mean\\nkgK mineral\\nper ha\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tKmin_per_km2, \"tons of K mineral\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\nf_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\nCode\nf_graph_distribution(raster_density, tNorg_per_km2, \"tons of N organic\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\nf_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied\\nby crops\", resolution_meters,\n  sf_regions, \"#696969\"\n  ) + \n  labs(\n    title = name\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(values = fill_color) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE)\n    ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(legend.position = \"none\") +\n    labs(y=\"\") +\n    annotate(\n      x=x_intercept, y=0, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n\n\n\nCode\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    full_data, parcel_area_ha, \n    resolution_meters^2/10^4, \n    paste0(\"pixels \\nresolution: \\n\", km2_resolution,\" km2 = \\n\", ha_resolution, \" ha \"), \"#440154\"\n    ) +\n    labs(x=\"agricultural plots area (ha)\") +\n    scale_x_log10(limits=c(0.1, 3*ha_resolution)),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2, 100,\n    \"1 km2 = \\n100 ha  \", \"#5ec962\"\n    ) +\n    labs(x=\"ha per km2\\n(cannot be superior to 100)\") +\n    scale_x_continuous(limits=c(1, 150)),\n  \n  align = \"hv\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngraphs area, nb plots, catch and cover crops\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nrm(list = ls())"
  },
  {
    "objectID": "2_France.html",
    "href": "2_France.html",
    "title": "France",
    "section": "",
    "text": "Code\nknitr::opts_chunk$set(message=F, warning=F, results=F, fig.align = \"center\",  dev='png')\n\n# Load the function file common to all pages\nsource(\"functions.R\")\n#included:\n#-function to save csv f_save_csv_files\n#-set the default scale_color and scale_fill to viridis theme\n#-loads the core tidyverse package\n\nlibrary(arrow) #to read and write parquet file, and set objects to arrow tables\nlibrary(sf)\nlibrary(cowplot)\nlibrary(patchwork) #for multiple plots\n\n#set theme for graphs\ntheme_set(\n  theme_classic() +\n  theme(\n    panel.grid.major.y = element_line(), #no vertical lines by default\n    #text = element_text(family = \"Times New Roman\"), #default font\n    plot.title = element_text(face=\"bold\"), #graphs titles in bolds\n    )\n  )\n\nCRS_RGF93_Lambert93 &lt;- 2154 # number of coordinate projection system used for France (Réseau Géodésique Français 1993 - Lambert 93)\n\n# molar mass K : 39, O : 16\nK2O_K_conversion_factor &lt;- (2*39)/(2*39+16)\n# molar mass P : 31, O : 16\nP2O5_P_conversion_factor &lt;- (2*31)/(2*31+5*16)\n\n\n\nLoad and prepare data\n\nour dataFAO and UNIFA data\n\n\nOur data prepared from all the regions in prepare fertilizatio\n\n\nCode\n#function to synthesize the values at the regional scale\nf_regional_synthesis &lt;- function(dataset, grouping_var) {\n  \n  # Synthesize regional results\n  dataset &lt;- dataset %&gt;%\n    group_by(!!! syms(grouping_var)) %&gt;%\n    summarise(\n      `area (Mha)` = sum(parcel_area_ha, na.rm = TRUE) / 10^6,\n      `N mineral fertilization (ktN)` = sum(`N mineral fertilization (kgN)`, na.rm = TRUE) / 10^6,\n      `P mineral fertilization (ktP)` = sum(`P mineral fertilization (kgP)`, na.rm = TRUE) / 10^6,\n      `K mineral fertilization (ktK)` = sum(`K mineral fertilization (kgK)`, na.rm = TRUE) / 10^6,\n      `N organic fertilization (ktN)` = sum(`N organic fertilization (kgN)`, na.rm = TRUE) / 10^6\n    ) %&gt;%\n    collect()\n  \n  return(dataset)\n}\n\n\n# read full data 2015 year for France parcels\ntemp &lt;- read_parquet(\"output/full_data/France_2015.parquet\")\n\n# initiate France syntheses files with 2015 year\nsynthesis_france &lt;- f_regional_synthesis(temp, c(\"Year\")) # national scale\nsynthesis_regional &lt;- f_regional_synthesis(temp, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\")) # regional scale\nsynthesis_regional_old &lt;- f_regional_synthesis(temp, c(\"Year\", \"code_old_region_parcel\", \"name_old_region_parcel\")) # old regions scale\n\n# add years 2016 to 2020 to initial 2015 summarized data\nfor (i in 2016:2020) {\n  # read full data for year i\n  data_year_i &lt;- read_parquet(paste0(\"output/full_data/France_\", as.character(i), \".parquet\"))\n  \n  # synthesis national scale\n  data_year_i_synthesized &lt;- f_regional_synthesis(data_year_i, c(\"Year\"))\n  synthesis_france &lt;- bind_rows(synthesis_france, data_year_i_synthesized)\n  \n  # synthesis national scale\n  data_year_i_synthesized &lt;- f_regional_synthesis(data_year_i, c(\"Year\", \"code_region_parcel\", \"name_region_parcel\"))\n  synthesis_regional &lt;- bind_rows(synthesis_regional, data_year_i_synthesized)\n  \n  # synthesis national scale\n  data_year_i_synthesized &lt;- f_regional_synthesis(data_year_i, c(\"Year\", \"code_old_region_parcel\", \"name_old_region_parcel\"))\n  synthesis_regional_old &lt;- bind_rows(synthesis_regional_old, data_year_i_synthesized)\n}\n\nrm(temp, data_year_i, data_year_i_synthesized)\n\n\n\n\nUsed to compare our results to official values.\nLoad FAO values (comes from processed FAO data, see the output of this other project).\n\n\nCode\nFAO &lt;- read_csv(\"source/FAO/fao_manure_fertilizers_balance_food_supply_countries.csv\")\nFAO &lt;- FAO %&gt;% \n  filter(\n    Year&lt;2021 & Year&gt;2014,\n    country==\"France\"\n  )\n\n\nUNIFA values found on their website, for 2017-2018, 2018-2019, 2019-2020, 2020-2021\n\n\nCode\nUNIFA &lt;- read_csv(\"source/fertilization/fertilizers_unifa_data.csv\")\n\nUNIFA &lt;- UNIFA %&gt;%\n  #transforms tons to ktons and P2O5 and K2O to P and K\n  mutate(\n    `N mineral fertilization (ktN)` = N/1000,\n    `P mineral fertilization (ktP)` = P2O5*P2O5_P_conversion_factor/1000,\n    `K mineral fertilization (ktK)` = K2O*K2O_K_conversion_factor/1000\n    ) %&gt;%\n  rename(\n    name_region_parcel = name_region\n  )\n\nUNIFA_regional &lt;- UNIFA %&gt;%\n  group_by(Year, name_region_parcel) %&gt;%\n  summarise(\n    `N mineral fertilization (ktN)` = sum(`N mineral fertilization (ktN)`, na.rm=T),\n    `P mineral fertilization (ktP)` = sum(`P mineral fertilization (ktP)`, na.rm=T),\n    `K mineral fertilization (ktK)` = sum(`K mineral fertilization (ktK)`, na.rm=T),\n    )\n\nUNIFA_national&lt;- UNIFA %&gt;%\n  group_by(Year) %&gt;%\n  summarise(\n    `N mineral fertilization (ktN)` = sum(`N mineral fertilization (ktN)`, na.rm=T),\n    `P mineral fertilization (ktP)` = sum(`P mineral fertilization (ktP)`, na.rm=T),\n    `K mineral fertilization (ktK)` = sum(`K mineral fertilization (ktK)`, na.rm=T),\n    )\n\n\n\n\n\n\n\nComparison with official values\nGenerally, we underestimate the official values by less thant 10%, except. for potassium, where the discrepancy is higher.\n\nNational scaleRegional scale\n\n\n\n\nCode\ntemp &lt;- bind_rows(\n  synthesis_france %&gt;%\n    mutate(\n      source = \"our value\"\n      ),\n  FAO %&gt;% \n    select(\n      Year,\n      `N mineral fertilization (ktN)`,\n      `P mineral fertilization (ktP)`,\n      `K mineral fertilization (ktK)`,\n      `N organic fertilization (ktN)` = `All Animals Manure applied to soils (ktN)`\n      ) %&gt;%\n    mutate(\n      source = \"FAO\"\n      ),\n  UNIFA_national %&gt;%\n    mutate(\n      source = \"UNIFA\"\n      )\n)\n#order labels for graph display\ntemp$source = factor(temp$source, levels = c(\"FAO\", \"UNIFA\", \"our value\"))\n\n\nf_graph &lt;- function(variable, breaks_large, breaks_min){\n  ggplot(temp) +\n    geom_line(\n      aes(Year, {{ variable }}, color=source),\n      linewidth=2\n      ) +\n    scale_color_manual(\n      breaks = c(\"our value\", \"FAO\", \"UNIFA\"),\n      values=c(\"red\", \"black\", \"gray\")\n      ) +\n    labs(\n      x=element_blank(), color=element_blank()\n      ) +\n    scale_y_continuous(\n      breaks = seq(0, 2500, by = breaks_large),\n      minor_breaks = seq(0, 2500, by = breaks_min),\n      limits = c(0, NA)\n      ) + \n    theme(\n      panel.grid.minor.y = element_line()\n    )\n}\n\n#save graph for manuscript\ngg &lt;- f_graph(`N mineral fertilization (ktN)`, 500, 100) + labs(subtitle = \"France mineral N fertilization\", y=\"ktN\") +\n  f_graph(`P mineral fertilization (ktP)`, 40, 10) + labs(subtitle = \"France mineral P fertilization\", y=\"ktP\") + \n  f_graph(`K mineral fertilization (ktK)`, 100, 20) + labs(subtitle = \"France mineral K fertilization\", y=\"ktK\") +\n  f_graph(`N organic fertilization (ktN)`, 200, 50) + labs(subtitle = \"France organic N fertilization\", y=\"ktN\") +\n  plot_layout(guides = 'collect')\n\nf_save_graph_pdf_png(\n  gg, \"graph/france_fertilization/\", \"comparison_official_national_ferti\",\n  350, 5, 7\n)\n\n\n\nAbsoluteRelative\n\n\n\nNPKN org\n\n\n\n\nCode\nf_graph(`N mineral fertilization (ktN)`, 500, 100) + labs(subtitle = \"France mineral N fertilization\", y=\"ktN\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(`P mineral fertilization (ktP)`, 20, 10) + labs(subtitle = \"France mineral P fertilization\", y=\"ktP\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(`K mineral fertilization (ktK)`, 100, 20) + labs(subtitle = \"France mineral K fertilization\", y=\"ktK\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph(`N organic fertilization (ktN)`, 100, 50) + labs(subtitle = \"France organic N fertilization\", y=\"ktN\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nf_graph &lt;- function(variable){\n  temp &lt;- synthesis_france %&gt;% select(Year, {{ variable }})\n  \n  temp$`% of FAO value` &lt;- (temp %&gt;% pull({{ variable }})) / FAO %&gt;% pull({{ variable }})\n  temp$`% of UNIFA value`  &lt;- (temp %&gt;% pull({{ variable }})) / UNIFA_national %&gt;% pull({{ variable }})\n  \n  temp &lt;- temp %&gt;%\n    gather(source, value, `% of FAO value`, `% of UNIFA value`)\n  \n  gg &lt;- ggplot(data = temp) +\n    geom_line( \n      aes(x = Year, y = value, color=source),\n      linewidth=2\n      ) +\n    labs(\n      x = element_blank(), y = element_blank(), color=element_blank(),\n      title = \"Our value as % of official values\"\n      ) +\n    scale_color_manual(\n      breaks = c(\"% of FAO value\", \"% of UNIFA value\"),\n      values=c(\"black\", \"gray\")\n      ) +\n    scale_y_continuous(\n      labels = scales::percent_format(),\n      limits = c(0, NA),\n      breaks = seq(0, 1.2, by=0.1)\n      ) +\n    geom_hline(yintercept = 1, linetype=\"dashed\")\n  \n  return(gg)\n}\n\n\n\nN mineralP mineralK mineralN organic\n\n\nOur value is ~90-100% of FAO and UNIFA values.\n\n\nCode\nf_graph(`N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\n\n\nOur value is ~90-100% of FAO and UNIFA values.\n\n\nCode\nf_graph(`P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\n\n\nOur value is ~80-100% of FAO and UNIFA values.\n\n\nCode\nf_graph(`K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\nOur value is ~90-100% of FAO values.\n\n\nCode\ntemp &lt;- synthesis_france %&gt;% select(Year, `N organic fertilization (ktN)`)\ntemp$`% of FAO value` &lt;- (temp %&gt;% pull(`N organic fertilization (ktN)`)) / FAO %&gt;% pull(`All Animals Manure applied to soils (ktN)`)\ntemp &lt;- temp %&gt;%\n  gather(source, value, `% of FAO value`)\n\nggplot(data = temp) +\n  geom_line( \n    aes(x = Year, y = value, color=source),\n    linewidth=2\n    ) +\n  labs(\n    x = element_blank(), y = element_blank(), color=element_blank(),\n    title = \"Our value as % of official values\"\n    ) +\n  scale_color_manual(\n    breaks = c(\"% of FAO value\", \"% of UNIFA value\"),\n    values=c(\"black\", \"gray\")\n    ) +\n  scale_y_continuous(\n    labels = scales::percent_format(),\n    limits = c(0, NA),\n    breaks = seq(0, 1.2, by=0.1)\n    ) +\n  geom_hline(yintercept = 1, linetype=\"dashed\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ntemp &lt;- bind_rows(\n  synthesis_regional %&gt;%\n    mutate(\n      source = \"our value\"\n      ),\n  UNIFA_regional %&gt;%\n    mutate(\n      source = \"UNIFA\"\n      )\n)\n\nf_graph &lt;- function(variable){\n  \n  ggplot(temp %&gt;% filter(name_region_parcel != \"Corse\")) +\n    geom_line(\n      aes(Year, {{ variable }}, color=source),\n      linewidth=1.5\n      ) +\n    scale_color_manual(\n        breaks = c(\"UNIFA\", \"our value\"),\n        values=c(\"gray\", \"red\")\n        ) +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1),\n      legend.position = \"top\"\n      ) +\n    ylim(0, NA) +\n    labs(\n      x=element_blank(), color=element_blank()\n      ) +\n    facet_wrap(\n      vars(as.factor(name_region_parcel)), \n      scales=\"free_y\"\n      )\n  \n}\n\n\n\nN mineralP mineralK mineral\n\n\n\n\nCode\nf_graph(`N mineral fertilization (ktN)`)\n\n\n\n\n\n\n\n\n\nCode\n#save graph for manuscript\ngg &lt;- f_graph(`N mineral fertilization (ktN)`) + labs(y=\"ktN\", title = \"regional N mineral fertilization\")\nf_save_graph_pdf_png(\n  gg, \n  \"graph/france_fertilization/\", \"comparison_official_regional_ferti_N\",\n  350, 6, 9\n)\n\n\n\n\n\n\nCode\nf_graph(`P mineral fertilization (ktP)`)\n\n\n\n\n\n\n\n\n\nCode\n#save graph for manuscript, P and K regional fertilization\ngg &lt;- f_graph(`P mineral fertilization (ktP)`) + labs(y=\"ktP\", title = \"regional P mineral fertilization\") +\n  f_graph(`K mineral fertilization (ktK)`) + labs(y=\"ktK\", title = \"regional K mineral fertilization\") +\n  plot_layout(guides = \"collect\", ncol = 1) & theme(legend.position = 'bottom')\nf_save_graph_pdf_png(\n  gg, \n  \"graph/france_fertilization/\", \"comparison_official_regional_ferti_PK\",\n  350, 10, 9\n)\n\n\n\n\n\n\nCode\nf_graph(`K mineral fertilization (ktK)`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFertilization: map and distribution\n\n\nCode\n#create background France map\n\n#load map regions\nsf_regions &lt;- sf::st_read(\"source/maps/all_French_admin_units/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-11-20/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-11-20/ADE-COG_2-1_SHP_LAMB93_FR/REGION.shp\")\n#create whole francce polygon from regions polygon union\nsf_france &lt;- st_union(sf_regions)\n#simplify polygon for faster plotting\nsf_france &lt;- st_simplify(sf_france, 100, preserveTopology = T)\nrm(sf_regions)\n\n# resolution of raster pixels\nresolution_meters &lt;- 2000\nkm2_resolution &lt;- (resolution_meters/10^3)^2\nha_resolution &lt;- km2_resolution*100\n\n\n\n\nCode\n#selects columns for interest for year 2019\nFrance_full_data &lt;- read_parquet(\"output/full_data/France_2019.parquet\")\ndata_map &lt;- France_full_data %&gt;% \n  select(\n    parcel_area_ha, \n    kgNmin = `N mineral fertilization (kgN)`,\n    kgPmin = `P mineral fertilization (kgP)`,\n    kgKmin = `K mineral fertilization (kgK)`,\n    kgNorg = `N organic fertilization (kgN)`,\n    lat_RGF93_LAMB_93_parcel, lon_RGF93_LAMB_93_parcel\n    ) \n\n#sf for geographical\ndata_map &lt;- st_as_sf(data_map, coords = c(\"lon_RGF93_LAMB_93_parcel\", \"lat_RGF93_LAMB_93_parcel\"), crs = CRS_RGF93_Lambert93) \n\n#create raster\nraster_density &lt;- f_prepare_raster(\n  data_map, \n  parcel_area_ha, kgNmin, kgPmin, kgKmin, kgNorg,\n  resolution_meters, sf_france\n  )\n\n#compute total N fertilization mineral + organic\nraster_density &lt;- raster_density %&gt;%\n  mutate(\n    kgNtot = kgNmin + kgNorg,\n    tNtot_per_km2 = tNmin_per_km2 + tNorg_per_km2,\n    mean_kgNtot_per_ha = mean_kgNmin_per_ha + mean_kgNorg_per_ha\n    )\n\nf_save_csv_files(\n  raster_density %&gt;%\n    rename(\n      lon_RGF93_LAMB_93_parcel = x,\n      lat_RGF93_LAMB_93_parcel = y\n    ),\n  \"output/full_data/\",\n  \"France_2018_raster.csv\"\n)\n\n\n\nNitrogenP minK minAreaResolution consistency\n\n\n\nMineralOrganicTotal\n\n\n\nFertilizationFertilization only on agricultural land\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNmin_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\ngg_Nmin &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral N\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mineral N fertilization in France (~ 2000 ktN)\"\n    )\ngg_Nmin\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"mean_kgNmin_per_ha\", c(0, 30, 50, 80, 120, 100000), c(\"&lt; 30\", \"30 - 50\", \"50 - 80\", \"80 - 120\", \"&gt;120\"))\n\ngg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"mean kg of\\nmineral N\\nper ha of\\nagricultural\\nand\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mean mineral N fertilization in France\"\n    )\ngg\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFertilizationFertilization only on agricultural land\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNorg_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\ngg_Norg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"tons of\\norganic N\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Organic N fertilization to cropland in France (~ 850 ktN)\",\n    subtitle = \"Only managed manure:\\ndoes not include manure left on pasture\"\n    )\ngg_Norg\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"mean_kgNorg_per_ha\", c(0, 30, 50, 80, 120, 100000), c(\"&lt; 30\", \"30 - 50\", \"50 - 80\", \"80 - 120\", \"&gt;120\"))\n\ngg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"mean kg of\\norganic N\\nper ha of\\nagricultural\\nand\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mean organic N fertilization in France\"\n    )\ngg\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFertilizationFertilization only on agricultural land\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tNtot_per_km2\", c(0, 1, 3, 5, 10, 100000), c(\"&lt; 1\", \"1 - 3\", \"3 - 5\", \"5 - 10\", \"&gt;10\"))\n\ngg_Ntot &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"tons of\\ntotal N\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Total N fertilization in France (~ 2850 ktN)\"\n    )\ngg_Ntot\n\n\n\n\n\n\n\n\n\nCode\n#save for manuscript\ngg_Ntot &lt;- gg_Ntot + labs(title = element_blank(), caption = element_blank(), subtitle = \"total N fertilization\", fill = \"tons of N\\nper km2\")\nf_save_graph_pdf_png(\n  gg_Ntot, \"graph/france_fertilization/\", \"map_Ntot_ferti\",\n  1000, 5, 6\n)\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"mean_kgNtot_per_ha\", c(0, 30, 50, 80, 120, 100000), c(\"&lt; 30\", \"30 - 50\", \"50 - 80\", \"80 - 120\", \"&gt;120\"))\n\ngg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"mean kg of\\ntotal N\\nper ha of\\nagricultural\\nand\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mean total N fertilization in France\"\n    )\ngg\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFertilizationFertilization only on agricultural land\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tPmin_per_km2\", c(0, .1, .3, .5, 1, 100000), c(\"&lt; 0.1\", \"0.1 - 0.3\", \"0.3 - 0.5\", \"0.5 - 1\",\"&gt; 1\"))\n\ngg_Pmin &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral P\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mineral P fertilization in France (~ 200 ktP)\"\n    )\ngg_Pmin\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"mean_kgPmin_per_ha\", c(0, 3, 5, 8, 12, 100000), c(\"&lt; 3\", \"3 - 5\", \"5 - 8\", \"8 - 12\", \"&gt;12\"))\n\ngg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"mean kg of\\nmineral P\\nper ha of\\nagricultural\\nand\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mean mineral P fertilization in France\"\n    )\ngg\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFertilizationFertilization only on agricultural land\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"tKmin_per_km2\", c(0, .2, .6, 1, 2, 100000),  c(\"&lt; 0.2\", \"0.2 - 0.6\", \"0.6 - 1\", \"1 - 2\",\"&gt; 2\"))\n\ngg_Kmin &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"tons of\\nmineral K\\nper km2\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mineral K fertilization in France (~ 400 ktK)\"\n    )\ngg_Kmin\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"mean_kgKmin_per_ha\", c(0, 7, 10, 15, 20, 100000), c(\"&lt; 7\", \"7 - 10\", \"10 - 15\", \"15 - 20\", \"&gt; 20\"))\n\ngg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"mean kg of\\nmineral K\\nper ha of\\nagricultural\\nland\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Mean mineral K fertilization in France\"\n    )\ngg\n\n\n\n\n\n\n\n\n\n\n\nCode\n#save Nmin and Norg for manuscript \ngg &lt;- gg_Nmin + labs(caption = element_blank(), subtitle = \"mineral N\", title = element_blank(), fill = \"tons of N\\nper km2\") + \n  gg_Norg + labs(caption = element_blank(), subtitle = \"organic N\", title = element_blank(), fill = \"tons of N\\nper km2\") + \n  plot_layout(guides = \"collect\", nrow=2) \nf_save_graph_pdf_png(\n  gg, \"graph/france_fertilization/\", \"map_Nmin_Norg_ferti\",\n  1000, 10, 6\n)\n\n#save Pmin and Kmin for manuscript \ngg &lt;- gg_Pmin + \n  labs(\n    caption = element_blank(), subtitle = \"mineral P\", title = element_blank()\n    ) + \n  gg_Kmin + \n  labs(\n    caption = element_blank(), subtitle = \"mineral K\", title = element_blank()\n    ) +\n  plot_layout(ncol=1) \nf_save_graph_pdf_png(\n  gg, \"graph/france_fertilization/\", \"map_Pmin_Kmin_ferti\",\n  1000, 10, 6\n)\n\n\n\n\n\n\n\n\n\nCode\nraster_density &lt;- f_categorize_densities(\n  raster_density, \"ha_per_km2\", \n  c(0, 25, 50, 75, 1000), \n  c(\"0 - 25 %\", \"25 - 50 %\", \"50 - 75 %\",\"75 - 100 %\")\n  )\n\ngg &lt;- f_grap_map_raster(\n  raster_density, \n  category, \"% area\\noccupied by\\nagriculture\", resolution_meters,\n  sf_france, \"#440154\"\n  ) + \n  labs(\n    title = \"Share of area occupied by nagriculture\"\n    )\ngg\n\n\n\n\n\n\n\n\n\nCode\n#save area for manuscript \ngg &lt;- gg + labs(caption=element_blank(), title=element_blank())\nf_save_graph_pdf_png(\n  gg, \"graph/france_fertilization/\", \"map_area\",\n  500, 6, 7\n)\n\n\n\n\n\n\nCode\n#produces distribution graphs, annotated, to check if the 10 km2 resolution used is legit\nf_graph_distribution_consistency &lt;- function(dataset, variable, x_intercept, annotation_label, fill_color, x_lim_min, x_lim_max, y_label){\n  gg &lt;- ggplot(dataset) + \n    geom_histogram(\n      aes({{ variable }}, weight = {{ variable }}, fill=\"\"),\n      alpha=.7, bins = 100,\n      ) + \n    scale_fill_manual(\n      values = fill_color\n      ) +\n    scale_x_log10(\n      labels=scales::label_number(drop0trailing = TRUE), \n      limits = c(x_lim_min, x_lim_max)\n      ) +\n    geom_vline(\n      xintercept = x_intercept,\n      linetype=\"dashed\"\n      ) +\n    theme(\n      legend.position = \"none\"\n      ) +\n    labs(\n      y=element_blank()\n      ) +\n    annotate(\n      x=x_intercept, y=y_label, geom=\"text\", label=annotation_label, hjust=1, vjust=0\n    )\n  \n  return(gg)\n}\n\n#plot the 2 distribution graphs\nplot_grid(\n  \n  f_graph_distribution_consistency(\n    data_map, parcel_area_ha, ha_resolution, \"\", \"#440154\",\n    0.1, 1000, 7500\n    ) +\n    labs(\n      subtitle = \"parcels area distribution\",\n      x=\"parceal area (ha)\"\n      ) +\n    theme(\n      axis.text.y = element_blank()\n      ),\n  \n  f_graph_distribution_consistency(\n    raster_density, ha_per_km2*resolution_meters/1000, ha_resolution,\n    paste0(\"pixels area: \\n\", km2_resolution,\" km2 = \", ha_resolution, \" ha \"), \"#5ec962\",\n    10, 1000, 700000\n    ) +\n    labs(\n      x=\"ha of parcels per pixel\\n(should not be superior to 400)\",\n      subtitle = \"parcels area aggregated in pixels\"\n      ) +\n    theme(\n      axis.text.y = element_blank()\n      ),\n  \n  align = \"hv\"\n) + \n  plot_annotation(title = \"Consistency of pixels resolution\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistributions by crop type\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nend\n\n\nCode\n# \n# test &lt;- RPG %&gt;%\n#   group_by(Year) %&gt;%\n#   summarize(\n#     `nb of plots` = n()/10^6,\n#     `unreported fertilization` = sum(is.na(ferti_tot))/10^6,\n#     `reported fertilization` = sum(!is.na(ferti_tot))/10^6,\n#   ) \n# \n# g1 &lt;- test %&gt;%\n#   select(Year, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   gather(`plots with`, value, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   ggplot(aes(x = Year)) +\n#   geom_area(aes(y = value, fill = `plots with`)) +\n#   labs(\n#     fill = \"\",\n#     subtitle = \"agricultural plots\",\n#     y = \"millions plots\",\n#     x=\"\"\n#     ) +\n#   theme(legend.position = \"bottom\")\n# \n# test &lt;- test %&gt;%\n#   mutate(\n#     `reported fertilization` = (`reported fertilization` / `nb of plots`) * 100,\n#     `unreported fertilization` = (`unreported fertilization` / `nb of plots`) * 100\n#     )\n# g2 &lt;- test %&gt;%\n#   select(Year, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   gather(`% plots with`, value, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   ggplot(aes(x = Year)) +\n#   geom_area(aes(y = value, fill = `% plots with`)) +\n#   labs(\n#     fill = \"\",\n#     subtitle = \"% of agricultural plots\",\n#     y = \"%\",\n#     x=\"\"\n#     ) +\n#   theme(legend.position = \"bottom\")\n# \n# test &lt;- RPG %&gt;%\n#   group_by(Year) %&gt;%\n#   summarize(\n#     `agricultural land area` = sum(parcel_area_ha),\n#     `unreported fertilization` = sum(parcel_area_ha * is.na(ferti_tot)),\n#     `reported fertilization` = sum(SURF_PARC * !is.na(ferti_tot))\n#   )\n# g3 &lt;- test %&gt;%\n#   select(Year, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   gather(`area with`, value, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   ggplot(aes(x = Year)) +\n#   geom_area(aes(y = value/10^6, fill = `area with`)) +\n#   labs(\n#     fill = \"\",\n#     subtitle = \"agricultural land area\", \n#     y = \"millions ha\",\n#     x=\"\"\n#     ) +\n#   geom_hline(yintercept = 29) +\n#   theme(legend.position = \"bottom\")\n# \n# test &lt;- test%&gt;%\n#   mutate(\n#     `unreported fertilization` = (`unreported fertilization` / `agricultural land area`) * 100,\n#     `reported fertilization`  = (`reported fertilization`  / `agricultural land area`) * 100\n#     )\n# g4 &lt;- test %&gt;%\n#   select(Year, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   gather(`area with`, value, `unreported fertilization`, `reported fertilization`) %&gt;%\n#   ggplot(aes(x = Year)) +\n#   geom_area(aes(y = value, fill = `area with`)) +\n#   labs(\n#     fill = \"\",\n#     subtitle = \"% of agricultural land area\", \n#     y = \"%\",\n#     x=\"\"\n#     )  +\n#   theme(legend.position = \"bottom\")\n# \n# \n# \n# g1 + g2 + g3 + g4 + plot_layout(guides = \"collect\") + plot_annotation(\n#   theme = theme(legend.position = \"bottom\")\n# ) \n\n\n\n\nCode\nrm(list = ls())"
  }
]